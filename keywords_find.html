<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyword Combination & arXiv Search</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        #progress-bar {
            width: 0%;
            height: 10px;
            background-color: green;
        }
    </style>
</head>

<body class="bg-gray-100 p-4">

    <div class="max-w-4xl mx-auto bg-white shadow-md rounded-lg p-6">
        <h1 class="text-2xl font-semibold mb-4">Keyword Combination & arXiv Search</h1>

        <!-- Keyword Input Section -->
        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Keywords</h2>
            <div class="mb-2">
                <label for="primaryKeywords" class="block text-gray-700 text-sm font-bold mb-2">Primary Keywords
                    (comma-separated):</label>
                <input type="text" id="primaryKeywords"
                    class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    placeholder="e.g., Machine Learning, Deep Learning">
            </div>
            <div class="mb-2">
                <label for="secondaryKeywords" class="block text-gray-700 text-sm font-bold mb-2">Secondary Keywords
                    (comma-separated):</label>
                <input type="text" id="secondaryKeywords"
                    class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
                    placeholder="e.g., NLP, Computer Vision">
            </div>
            <button id="addKeywords"
                class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Add/Update Keywords
            </button>
        </div>

        <!-- Configuration Section -->
        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Configuration</h2>
            <div class="mb-2">
                <label for="maxResults" class="block text-gray-700 text-sm font-bold mb-2">Max Results per
                    Combination:</label>
                <input type="number" id="maxResults" value="100"
                    class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>

            <div class="mb-2">
                <label for="maxKeywords" class="block text-gray-700 text-sm font-bold mb-2">Max Keywords Combination Length:</label>
                <input type="number" id="maxKeywords" value="5"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
        </div>


        <!-- Combination Generation and Search Section -->
        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Generate Combinations & Search</h2>
            <button id="generateCombinations"
                class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Generate Combinations
            </button>
            <button id="startSearch"
                    class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Start Search
            </button>
        </div>

        <!-- Display Areas -->
        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Generated Combinations</h2>
            <ul id="generatedCombinationsList" class="list-disc pl-5"></ul>
        </div>

        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Valid Keyword Combinations</h2>
            <ul id="validCombinationsList" class="list-disc pl-5"></ul>
        </div>

        <div class="mb-4">
            <h2 class="text-lg font-medium mb-2">Search Progress</h2>
            <div id="progress-bar-container" class="bg-gray-300 rounded-full h-2">
                <div id="progress-bar" class="rounded-full h-2"></div>
            </div>
            <p id="progress-text">0% Complete</p>
        </div>

        <!-- Export & Clear -->
        <div>
            <button id="exportCombinations"
                class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Export Combinations
            </button>
            <button id="clearAll"
                class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                Clear All
            </button>
        </div>

        <!-- Error/Message Display -->
        <div id="messageArea" class="mt-4 text-red-500"></div>

    </div>

    <script>
        const primaryKeywordsInput = document.getElementById('primaryKeywords');
        const secondaryKeywordsInput = document.getElementById('secondaryKeywords');
        const addKeywordsButton = document.getElementById('addKeywords');
        const generateCombinationsButton = document.getElementById('generateCombinations');
        const startSearchButton = document.getElementById('startSearch');
        const validCombinationsList = document.getElementById('validCombinationsList');
        const exportCombinationsButton = document.getElementById('exportCombinations');
        const clearAllButton = document.getElementById('clearAll');
        const messageArea = document.getElementById('messageArea');
        const maxResultsInput = document.getElementById('maxResults');
        const maxKeywordsInput = document.getElementById('maxKeywords');
        const generatedCombinationsList = document.getElementById('generatedCombinationsList');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');


        let primaryKeywords = [];
        let secondaryKeywords = [];
        let validCombinations = [];
        let generatedCombinations = [];

        // Helper Functions
        function displayMessage(message) {
            messageArea.textContent = message;
        }

        function clearMessage() {
            messageArea.textContent = '';
        }

        function updateUI() {
            renderValidCombinations();
        }

        function renderGeneratedCombinations() {
            generatedCombinationsList.innerHTML = '';
            generatedCombinations.forEach(combination => {
                const li = document.createElement('li');
                li.textContent = combination;
                generatedCombinationsList.appendChild(li);
            });
        }

        function renderValidCombinations() {
            validCombinationsList.innerHTML = '';
            validCombinations.forEach(combination => {
                const li = document.createElement('li');
                li.textContent = combination;
                validCombinationsList.appendChild(li);
            });
        }

        function generateKeywordCombinations(pKeywords, sKeywords, maxLength) {
            const combinations = [];

            function combine(currentCombination, remainingPrimary, remainingSecondary) {
                if (currentCombination.length > maxLength) {
                    return;
                }

                if (currentCombination.length > 0 && currentCombination.some(keyword => pKeywords.includes(keyword))) { // Ensure at least one primary keyword

                    const combinationString = currentCombination.join(', ');
                    if (!isCombinationSubset(combinationString, validCombinations)) {
                        combinations.push(combinationString);
                    }

                }

                if (remainingPrimary.length === 0 && remainingSecondary.length === 0) {
                    return;
                }

                for (let i = 0; i < remainingPrimary.length; i++) {
                    const newCombination = [...currentCombination, remainingPrimary[i]];
                    const newRemainingPrimary = remainingPrimary.slice(i + 1);
                    combine(newCombination, newRemainingPrimary, remainingSecondary);
                }

                for (let i = 0; i < remainingSecondary.length; i++) {
                    const newCombination = [...currentCombination, remainingSecondary[i]];
                    const newRemainingSecondary = remainingSecondary.slice(i + 1);
                    combine(newCombination, remainingPrimary, newRemainingSecondary);
                }
            }

            combine([], pKeywords, sKeywords);
            return combinations;
        }


        function isCombinationSubset(newCombination, existingCombinations) {
            const newKeywords = newCombination.split(', ').sort();

            for (const existingCombination of existingCombinations) {
                const existingKeywords = existingCombination.split(', ').sort();

                if (newKeywords.length > existingKeywords.length) {
                    // New combination can't be a subset if it has more keywords
                    continue;
                }

                let isSubset = true;
                for (const keyword of newKeywords) {
                    if (!existingKeywords.includes(keyword)) {
                        isSubset = false;
                        break;
                    }
                }

                if (isSubset) {
                    return true;
                }
            }
            return false;
        }

        function isCombinationSuperset(newCombination, existingCombinations) {
            const newKeywords = newCombination.split(', ').sort();

            for (const existingCombination of existingCombinations) {
                const existingKeywords = existingCombination.split(', ').sort();

                if (newKeywords.length < existingKeywords.length) {
                    // New combination can't be a superset if it has fewer keywords
                    continue;
                }

                let isSuperset = true;
                for (const keyword of existingKeywords) {
                    if (!newKeywords.includes(keyword)) {
                        isSuperset = false;
                        break;
                    }
                }

                if (isSuperset) {
                    return true;
                }
            }
            return false;
        }



        function searchArxiv(combination, maxResults) {
            return new Promise((resolve, reject) => {
                const query = combination.split(', ').map(keyword => `ti:${keyword.trim()}`).join(' OR ');
                const url = `http://export.arxiv.org/api/query?search_query=${query}&start=0&max_results=${maxResults}`;

                const xhr = new XMLHttpRequest();
                xhr.open('GET', url);

                xhr.onload = () => {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(xhr.responseText, "text/xml");
                        const entries = xmlDoc.querySelectorAll('entry');
                        resolve(entries.length); // Return number of results
                    } else {
                        reject(xhr.statusText);
                    }
                };

                xhr.onerror = () => reject(xhr.statusText);
                xhr.send();
            });
        }


        async function performSearch(combinations, maxResults) {
            const numCombinations = combinations.length;
            let completedCombinations = 0;

            for (const combination of combinations) {
                if (isCombinationSuperset(combination, validCombinations)) {
                    console.log(`Skipping superset combination: ${combination}`);
                    completedCombinations++;
                    updateProgressBar(completedCombinations, numCombinations);
                    continue;
                }
                try {
                    const resultCount = await searchArxiv(combination, maxResults);
                    if (resultCount > 0 && resultCount <= maxResults) {
                        console.log(`Combination "${combination}" found ${resultCount} results.`);
                        validCombinations.push(combination);
                        updateUI();


                        //Split the primary results and search again
                        let newPrimaryKeyword=combination.split(',')[0];
                        console.log(`Split and adding new keyword: ${newPrimaryKeyword}`);

                        if (!primaryKeywords.includes(newPrimaryKeyword))
                            primaryKeywords.push(newPrimaryKeyword)
                        
                        generatedCombinations = generateKeywordCombinations(primaryKeywords, secondaryKeywords, parseInt(maxKeywordsInput.value));
                        renderGeneratedCombinations()

                    } else if (resultCount > maxResults) {
                        displayMessage(`Combination "${combination}" returned more than ${maxResults} results. Consider adding more keywords.`);
                    } else {
                        console.log(`Combination "${combination}" returned no results.`);
                    }
                } catch (error) {
                    displayMessage(`Error searching for combination "${combination}": ${error}`);
                }
                completedCombinations++;
                updateProgressBar(completedCombinations, numCombinations);
            }
        }

        function updateProgressBar(completed, total) {
            const percentage = (completed / total) * 100;
            progressBar.style.width = `${percentage}%`;
            progressText.textContent = `${percentage.toFixed(1)}% Complete`;
        }


        // Event Listeners
        addKeywordsButton.addEventListener('click', () => {
            clearMessage();
            const newPrimary = primaryKeywordsInput.value.split(',').map(keyword => keyword.trim()).filter(keyword => keyword !== '');
            const newSecondary = secondaryKeywordsInput.value.split(',').map(keyword => keyword.trim()).filter(keyword => keyword !== '');

            primaryKeywords = [...new Set([...primaryKeywords, ...newPrimary])];
            secondaryKeywords = [...new Set([...secondaryKeywords, ...newSecondary])];

            primaryKeywordsInput.value = primaryKeywords.join(', ');
            secondaryKeywordsInput.value = secondaryKeywords.join(', ');

            console.log('Primary Keywords:', primaryKeywords);
            console.log('Secondary Keywords:', secondaryKeywords);
        });

        generateCombinationsButton.addEventListener('click', () => {
            clearMessage();
            generatedCombinations = generateKeywordCombinations(primaryKeywords, secondaryKeywords, parseInt(maxKeywordsInput.value));
            renderGeneratedCombinations();
        });

        startSearchButton.addEventListener('click', () => {
            clearMessage();
            validCombinations = [];
            updateUI();
            const maxResults = parseInt(maxResultsInput.value);
            progressBar.style.width = '0%';
            progressText.textContent = '0% Complete';
            performSearch(generatedCombinations, maxResults);
        });

        exportCombinationsButton.addEventListener('click', () => {
            const dataStr = "data:text/plain;charset=utf-8," + encodeURIComponent(validCombinations.join('; '));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "keyword_combinations.txt");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        clearAllButton.addEventListener('click', () => {
            primaryKeywords = [];
            secondaryKeywords = [];
            validCombinations = [];
            generatedCombinations = [];
            primaryKeywordsInput.value = '';
            secondaryKeywordsInput.value = '';
            generatedCombinationsList.innerHTML = '';
            validCombinationsList.innerHTML = '';
            progressBar.style.width = '0%';
            progressText.textContent = '0% Complete';
            clearMessage();
            updateUI();
        });


        //Tests
        function testKeywordCombinations() {
            console.assert(generateKeywordCombinations(["A"], ["B"],2).length === 2, "Test Failed: Basic combination generation");
            console.assert(isCombinationSubset("A, B", ["A, B, C"]) === true, "Test Failed: Subset check true");
            console.assert(isCombinationSubset("A, B, C", ["A, B"]) === false, "Test Failed: Subset check false");
            console.assert(isCombinationSuperset("A, B, C", ["A, B"]) === true, "Test Failed: Superset check true");
            console.assert(isCombinationSuperset("A, B", ["A, B, C"]) === false, "Test Failed: Superset check false");
            console.log("All tests passed!");
        }

        testKeywordCombinations()
    </script>

</body>

</html>

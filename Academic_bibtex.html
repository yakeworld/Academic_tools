<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Markdown Citation Manager</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Marked.js for Markdown parsing - using specific version for reliability -->
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    
    <!-- DOMPurify for sanitizing HTML output -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
    
    <!-- Citation.js library - unified version 0.7.18 with defer to ensure proper loading -->
    <script src="https://cdn.jsdelivr.net/npm/citation-js@0.7.18/build/citation.js" defer></script>
    
    <!-- CSL engine directly - using the specified CommonJS version -->
    <script src="https://cdn.jsdelivr.net/npm/citeproc@2.4.63/citeproc_commonjs.min.js"></script>
    
    <!-- Fallback for Citation.js if it fails to load -->
    <script>
    // Define global Cite if it's not available after a timeout
    setTimeout(function() {
        if (typeof Cite === 'undefined') {
            console.warn('Citation.js not loaded after timeout, creating fallback');
            // Simple fallback implementation of Cite to avoid errors
            window.Cite = function(data) {
                this.data = Array.isArray(data) ? data : [];
                
                // Try to parse BibTeX directly if string is provided
                if (typeof data === 'string' && data.includes('@')) {
                    this.data = parseSimpleBibtex(data);
                }
            };
            
            // Add minimal methods to make it work with our code
            window.Cite.prototype.format = function() {
                return '';
            };
        }
    }, 2000); // Wait 2 seconds for the real library to load
    </script>
    
    <!-- CSL locale files -->
    <script>
        // Simplified English locale for CSL
        window.CSL_LOCALES = {
            "en-US": `<?xml version="1.0" encoding="utf-8"?>
<locale xmlns="http://purl.org/net/xbiblio/csl" version="1.0" xml:lang="en-US">
  <info>
    <rights license="http://creativecommons.org/licenses/by-sa/3.0/">This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License</rights>
    <updated>2015-10-10T23:31:02+00:00</updated>
  </info>
  <style-options punctuation-in-quote="true" 
                 initialize-with-hyphen="true" 
                 demote-non-dropping-particle="display-and-sort" 
                 page-range-format="expanded"/>
  <date form="text">
    <date-part name="month" suffix=" "/>
    <date-part name="day" suffix=", "/>
    <date-part name="year"/>
  </date>
  <date form="numeric">
    <date-part name="month" form="numeric-leading-zeros" suffix="/"/>
    <date-part name="day" form="numeric-leading-zeros" suffix="/"/>
    <date-part name="year"/>
  </date>
  <terms>
    <term name="accessed">accessed</term>
    <term name="and">and</term>
    <term name="and others">and others</term>
    <term name="anonymous">anonymous</term>
    <term name="anonymous" form="short">anon.</term>
    <term name="at">at</term>
    <term name="available at">available at</term>
    <term name="by">by</term>
    <term name="circa">circa</term>
    <term name="circa" form="short">c.</term>
    <term name="cited">cited</term>
    <term name="edition">
      <single>edition</single>
      <multiple>editions</multiple>
    </term>
    <term name="edition" form="short">ed.</term>
    <term name="et-al">et al.</term>
    <term name="forthcoming">forthcoming</term>
    <term name="from">from</term>
    <term name="ibid">ibid.</term>
    <term name="in">in</term>
    <term name="in press">in press</term>
    <term name="internet">internet</term>
    <term name="interview">interview</term>
    <term name="letter">letter</term>
    <term name="no date">no date</term>
    <term name="no date" form="short">n.d.</term>
    <term name="online">online</term>
    <term name="presented at">presented at the</term>
    <term name="reference">
      <single>reference</single>
      <multiple>references</multiple>
    </term>
    <term name="reference" form="short">
      <single>ref.</single>
      <multiple>refs.</multiple>
    </term>
    <term name="retrieved">retrieved</term>
    <term name="scale">scale</term>
    <term name="version">version</term>

    <!-- ANNO DOMINI; BEFORE CHRIST -->
    <term name="ad">AD</term>
    <term name="bc">BC</term>

    <!-- PUNCTUATION -->
    <term name="open-quote">"</term>
    <term name="close-quote">"</term>
    <term name="open-inner-quote">'</term>
    <term name="close-inner-quote">'</term>
    <term name="page-range-delimiter">–</term>

    <!-- ORDINALS -->
    <term name="ordinal">th</term>
    <term name="ordinal-01">st</term>
    <term name="ordinal-02">nd</term>
    <term name="ordinal-03">rd</term>
    <term name="ordinal-11">th</term>
    <term name="ordinal-12">th</term>
    <term name="ordinal-13">th</term>

    <!-- LONG ORDINALS -->
    <term name="long-ordinal-01">first</term>
    <term name="long-ordinal-02">second</term>
    <term name="long-ordinal-03">third</term>
    <term name="long-ordinal-04">fourth</term>
    <term name="long-ordinal-05">fifth</term>
    <term name="long-ordinal-06">sixth</term>
    <term name="long-ordinal-07">seventh</term>
    <term name="long-ordinal-08">eighth</term>
    <term name="long-ordinal-09">ninth</term>
    <term name="long-ordinal-10">tenth</term>

    <!-- LONG LOCATOR FORMS -->
    <term name="book">
      <single>book</single>
      <multiple>books</multiple>
    </term>
    <term name="chapter">
      <single>chapter</single>
      <multiple>chapters</multiple>
    </term>
    <term name="column">
      <single>column</single>
      <multiple>columns</multiple>
    </term>
    <term name="figure">
      <single>figure</single>
      <multiple>figures</multiple>
    </term>
    <term name="folio">
      <single>folio</single>
      <multiple>folios</multiple>
    </term>
    <term name="issue">
      <single>number</single>
      <multiple>numbers</multiple>
    </term>
    <term name="line">
      <single>line</single>
      <multiple>lines</multiple>
    </term>
    <term name="note">
      <single>note</single>
      <multiple>notes</multiple>
    </term>
    <term name="opus">
      <single>opus</single>
      <multiple>opera</multiple>
    </term>
    <term name="page">
      <single>page</single>
      <multiple>pages</multiple>
    </term>
    <term name="number-of-pages">
      <single>page</single>
      <multiple>pages</multiple>
    </term>
    <term name="paragraph">
      <single>paragraph</single>
      <multiple>paragraphs</multiple>
    </term>
    <term name="part">
      <single>part</single>
      <multiple>parts</multiple>
    </term>
    <term name="section">
      <single>section</single>
      <multiple>sections</multiple>
    </term>
    <term name="sub verbo">
      <single>sub verbo</single>
      <multiple>sub verbis</multiple>
    </term>
    <term name="verse">
      <single>verse</single>
      <multiple>verses</multiple>
    </term>
    <term name="volume">
      <single>volume</single>
      <multiple>volumes</multiple>
    </term>

    <!-- SHORT LOCATOR FORMS -->
    <term name="book" form="short">bk.</term>
    <term name="chapter" form="short">chap.</term>
    <term name="column" form="short">col.</term>
    <term name="figure" form="short">fig.</term>
    <term name="folio" form="short">f.</term>
    <term name="issue" form="short">no.</term>
    <term name="line" form="short">l.</term>
    <term name="note" form="short">n.</term>
    <term name="opus" form="short">op.</term>
    <term name="page" form="short">
      <single>p.</single>
      <multiple>pp.</multiple>
    </term>
    <term name="number-of-pages" form="short">
      <single>p.</single>
      <multiple>pp.</multiple>
    </term>
    <term name="paragraph" form="short">para.</term>
    <term name="part" form="short">pt.</term>
    <term name="section" form="short">sec.</term>
    <term name="sub verbo" form="short">
      <single>s.v.</single>
      <multiple>s.vv.</multiple>
    </term>
    <term name="verse" form="short">
      <single>v.</single>
      <multiple>vv.</multiple>
    </term>
    <term name="volume" form="short">
      <single>vol.</single>
      <multiple>vols.</multiple>
    </term>

    <!-- SYMBOL LOCATOR FORMS -->
    <term name="paragraph" form="symbol">
      <single>¶</single>
      <multiple>¶¶</multiple>
    </term>
    <term name="section" form="symbol">
      <single>§</single>
      <multiple>§§</multiple>
    </term>

    <!-- LONG ROLE FORMS -->
    <term name="director">
      <single>director</single>
      <multiple>directors</multiple>
    </term>
    <term name="editor">
      <single>editor</single>
      <multiple>editors</multiple>
    </term>
    <term name="editorial-director">
      <single>editor</single>
      <multiple>editors</multiple>
    </term>
    <term name="illustrator">
      <single>illustrator</single>
      <multiple>illustrators</multiple>
    </term>
    <term name="translator">
      <single>translator</single>
      <multiple>translators</multiple>
    </term>
    <term name="editortranslator">
      <single>editor &amp; translator</single>
      <multiple>editors &amp; translators</multiple>
    </term>

    <!-- SHORT ROLE FORMS -->
    <term name="director" form="short">
      <single>dir.</single>
      <multiple>dirs.</multiple>
    </term>
    <term name="editor" form="short">
      <single>ed.</single>
      <multiple>eds.</multiple>
    </term>
    <term name="editorial-director" form="short">
      <single>ed.</single>
      <multiple>eds.</multiple>
    </term>
    <term name="illustrator" form="short">
      <single>ill.</single>
      <multiple>ills.</multiple>
    </term>
    <term name="translator" form="short">
      <single>tran.</single>
      <multiple>trans.</multiple>
    </term>
    <term name="editortranslator" form="short">
      <single>ed. &amp; tran.</single>
      <multiple>eds. &amp; trans.</multiple>
    </term>

    <!-- VERB ROLE FORMS -->
    <term name="container-author" form="verb">by</term>
    <term name="director" form="verb">directed by</term>
    <term name="editor" form="verb">edited by</term>
    <term name="editorial-director" form="verb">edited by</term>
    <term name="illustrator" form="verb">illustrated by</term>
    <term name="interviewer" form="verb">interview by</term>
    <term name="recipient" form="verb">to</term>
    <term name="reviewed-author" form="verb">by</term>
    <term name="translator" form="verb">translated by</term>
    <term name="editortranslator" form="verb">edited &amp; translated by</term>

    <!-- SHORT VERB ROLE FORMS -->
    <term name="director" form="verb-short">dir. by</term>
    <term name="editor" form="verb-short">ed. by</term>
    <term name="editorial-director" form="verb-short">ed. by</term>
    <term name="illustrator" form="verb-short">illus. by</term>
    <term name="translator" form="verb-short">trans. by</term>
    <term name="editortranslator" form="verb-short">ed. &amp; trans. by</term>

    <!-- LONG MONTH FORMS -->
    <term name="month-01">January</term>
    <term name="month-02">February</term>
    <term name="month-03">March</term>
    <term name="month-04">April</term>
    <term name="month-05">May</term>
    <term name="month-06">June</term>
    <term name="month-07">July</term>
    <term name="month-08">August</term>
    <term name="month-09">September</term>
    <term name="month-10">October</term>
    <term name="month-11">November</term>
    <term name="month-12">December</term>

    <!-- SHORT MONTH FORMS -->
    <term name="month-01" form="short">Jan.</term>
    <term name="month-02" form="short">Feb.</term>
    <term name="month-03" form="short">Mar.</term>
    <term name="month-04" form="short">Apr.</term>
    <term name="month-05" form="short">May</term>
    <term name="month-06" form="short">Jun.</term>
    <term name="month-07" form="short">Jul.</term>
    <term name="month-08" form="short">Aug.</term>
    <term name="month-09" form="short">Sep.</term>
    <term name="month-10" form="short">Oct.</term>
    <term name="month-11" form="short">Nov.</term>
    <term name="month-12" form="short">Dec.</term>

    <!-- SEASONS -->
    <term name="season-01">Spring</term>
    <term name="season-02">Summer</term>
    <term name="season-03">Autumn</term>
    <term name="season-04">Winter</term>
  </terms>
</locale>`
        };
    </script>
    
    <!-- Ensure Citation.js is properly initialized with detailed debugging -->
    <script>
        // Track Citation.js loading status
        window.citationJsLoaded = false;
        window.citationJsDebug = {
            errors: [],
            loadStatus: 'Not started',
            cslSupport: false
        };
        
        // Function to check if Citation.js is properly loaded
        function initCitationJs() {
            window.citationJsDebug.loadStatus = 'Initialization started';
            
            if (typeof Cite === 'undefined') {
                console.warn('Citation.js not available yet, retrying in 500ms...');
                window.citationJsDebug.loadStatus = 'Cite not defined, retrying';
                setTimeout(initCitationJs, 500);
                return;
            }
            
            try {
                // Test if Citation.js is working properly with a minimal citation
                const testCite = new Cite();
                window.citationJsDebug.loadStatus = 'Basic initialization successful';
                
                // Test if CSL functionality works
                const testData = {
                    id: 'test123',
                    type: 'article',
                    title: 'Test Article',
                    author: [{ family: 'Smith', given: 'John' }],
                    issued: { 'date-parts': [[2020]] }
                };
                
                const testCiteWithData = new Cite(testData);
                const apaOutput = testCiteWithData.format('bibliography', { template: 'apa', format: 'text' });
                
                if (apaOutput && apaOutput.includes('Smith')) {
                    window.citationJsLoaded = true;
                    window.citationJsDebug.cslSupport = true;
                    window.citationJsDebug.loadStatus = 'Fully initialized with CSL support';
                    console.log('Citation.js successfully initialized with CSL support');
                    console.log('Test output:', apaOutput);
                } else {
                    window.citationJsDebug.loadStatus = 'CSL output test failed';
                    console.warn('Citation.js initialized but CSL output test failed');
                }
            } catch (e) {
                window.citationJsDebug.errors.push(e.message || 'Unknown error');
                window.citationJsDebug.loadStatus = 'Error during initialization';
                console.error('Citation.js initialization error:', e);
                window.citationJsLoaded = false;
            }
        }
        
        // Initialize Citation.js when the window loads
        window.addEventListener('load', initCitationJs);
    </script>
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4A49B7'
                    },
                    typography: {
                        DEFAULT: {
                            css: {
                                color: '#333',
                                a: {
                                    color: '#5D5CDE',
                                    '&:hover': {
                                        color: '#4A49B7',
                                    },
                                },
                            },
                        },
                        invert: {
                            css: {
                                color: '#DDD',
                                a: {
                                    color: '#8C8BFF',
                                    '&:hover': {
                                        color: '#ACACFF',
                                    },
                                },
                            },
                        },
                    },
                }
            },
            plugins: [
                function({ addBase }) {
                    // Add prose classes for Markdown rendering
                    addBase({
                        '.prose': {
                            'max-width': '65ch',
                            'color': 'inherit',
                            h1: { 'font-size': '2.25em', 'margin-top': '0', 'margin-bottom': '0.8888889em', 'line-height': '1.1111111' },
                            h2: { 'font-size': '1.5em', 'margin-top': '2em', 'margin-bottom': '1em', 'line-height': '1.3333333' },
                            h3: { 'font-size': '1.25em', 'margin-top': '1.6em', 'margin-bottom': '0.6em', 'line-height': '1.6' },
                            p: { 'margin-top': '1.25em', 'margin-bottom': '1.25em' },
                            a: { 'color': '#5D5CDE', 'text-decoration': 'underline', 'font-weight': '500' },
                            strong: { 'font-weight': '600' },
                            ul: { 'list-style-type': 'disc', 'margin-top': '1.25em', 'margin-bottom': '1.25em', 'padding-left': '1.625em' },
                            ol: { 'list-style-type': 'decimal', 'margin-top': '1.25em', 'margin-bottom': '1.25em', 'padding-left': '1.625em' },
                            li: { 'margin-top': '0.5em', 'margin-bottom': '0.5em' },
                            blockquote: { 'font-weight': '500', 'font-style': 'italic', 'color': 'inherit', 'border-left-width': '0.25rem', 'border-color': '#5D5CDE', 'quotes': '"\\201C""\\201D""\\2018""\\2019"', 'margin-top': '1.6em', 'margin-bottom': '1.6em', 'padding-left': '1em' },
                            code: { 'color': 'inherit', 'font-weight': '600', 'font-size': '0.875em' },
                            'code::before': { 'content': '"`"' },
                            'code::after': { 'content': '"`"' },
                            pre: { 'color': '#e5e7eb', 'background-color': '#1f2937', 'overflow-x': 'auto', 'font-weight': '400', 'font-size': '0.875em', 'line-height': '1.7142857', 'margin-top': '1.7142857em', 'margin-bottom': '1.7142857em', 'border-radius': '0.375rem', 'padding-top': '0.8571429em', 'padding-right': '1.1428571em', 'padding-bottom': '0.8571429em', 'padding-left': '1.1428571em' },
                            'pre code': { 'background-color': 'transparent', 'border-width': '0', 'border-radius': '0', 'padding': '0', 'font-weight': 'inherit', 'color': 'inherit', 'font-size': 'inherit', 'font-family': 'inherit', 'line-height': 'inherit' },
                            'pre code::before': { 'content': 'none' },
                            'pre code::after': { 'content': 'none' },
                        },
                        '.prose-invert': {
                            'color': '#D1D5DB',
                            a: { 'color': '#8C8BFF' },
                            blockquote: { 'border-color': '#8C8BFF' },
                            pre: { 'background-color': '#111827' },
                        },
                        '.max-w-none': { 'max-width': 'none' }
                    });
                }
            ]
        }
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-primary text-white p-4 shadow-md dark:bg-gray-800">
        <h1 class="text-xl md:text-2xl font-bold">Academic Markdown Citation Manager</h1>
    </header>
    
    <!-- Main Content -->
    <main class="flex-grow flex flex-col p-2 md:p-4">
        <!-- Tabs -->
        <div class="flex border-b border-gray-300 dark:border-gray-700 mb-4">
            <button id="editor-tab" class="px-3 py-2 font-medium border-b-2 border-primary">Editor</button>
            <button id="bibtex-tab" class="px-3 py-2 font-medium text-gray-500 dark:text-gray-400">BibTeX</button>
            <button id="csl-tab" class="px-3 py-2 font-medium text-gray-500 dark:text-gray-400">Citation Style</button>
            <button id="help-tab" class="px-3 py-2 font-medium text-gray-500 dark:text-gray-400">Help</button>
        </div>
        
        <!-- Editor Tab Content -->
        <div id="editor-content" class="flex-grow flex flex-col md:flex-row gap-4">
            <!-- Left column - Editor -->
            <div class="flex-1 flex flex-col h-[calc(100vh-180px)]">
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-lg font-medium">Markdown</h2>
                    <div class="flex items-center gap-2">
                        <span id="available-citations" class="text-sm text-gray-500 dark:text-gray-400 hidden">
                            Citations: <span id="citation-count">0</span>
                        </span>
                        <button id="insert-citation" class="px-3 py-1 bg-primary text-white text-sm rounded disabled:opacity-50">
                            Insert Citation
                        </button>
                    </div>
                </div>
                <textarea id="markdown-editor" class="flex-grow p-4 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-base font-mono" placeholder="Write your markdown content here. Use [@key] to cite references."></textarea>
            </div>
            
            <!-- Right column - Preview -->
            <div class="flex-1 flex flex-col h-[calc(100vh-180px)]">
                <h2 class="text-lg font-medium mb-2">Preview</h2>
                <div id="preview" class="flex-grow p-4 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 overflow-auto prose dark:prose-invert max-w-none"></div>
            </div>
        </div>
        
        <!-- BibTeX Tab Content -->
        <div id="bibtex-content" class="flex-grow flex flex-col hidden">
            <div class="flex justify-between items-center mb-2">
                <h2 class="text-lg font-medium">BibTeX References</h2>
                <div class="flex items-center gap-2">
                    <button id="parse-bibtex-btn" class="px-3 py-1 bg-primary text-white text-sm rounded">
                        Parse BibTeX
                    </button>
                    <button id="show-references-btn" class="px-3 py-1 border border-gray-300 dark:border-gray-600 text-sm rounded hidden">
                        Show References
                    </button>
                </div>
            </div>
            <textarea id="bibtex-input" class="flex-grow p-4 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-base font-mono h-[calc(100vh-180px)]" placeholder="Paste your BibTeX references here..."></textarea>
            <div id="bibtex-status" class="mt-2 text-sm"></div>
            
            <!-- References Modal -->
            <div id="references-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-10">
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-2xl w-full max-h-[80vh] overflow-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-medium">Available References</h3>
                        <button id="close-references" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>
                    <div id="references-list" class="divide-y divide-gray-200 dark:divide-gray-700"></div>
                </div>
            </div>
        </div>
        
        <!-- CSL Tab Content -->
        <div id="csl-content" class="flex-grow flex flex-col hidden">
            <div class="mb-4">
                <h2 class="text-lg font-medium mb-2">Citation Style</h2>
                <select id="csl-style-select" class="w-full p-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-base">
                    <option value="apa">APA 7th Edition</option>
                    <option value="mla">MLA 8th Edition</option>
                    <option value="chicago">Chicago Author-Date</option>
                    <option value="ieee">IEEE</option>
                    <option value="harvard">Harvard</option>
                    <option value="vancouver">Vancouver</option>
                    <option value="custom">Custom CSL</option>
                </select>
            </div>
            
            <div id="custom-csl-container" class="flex-grow flex flex-col hidden">
                <h3 class="text-md font-medium mb-2">Custom CSL XML</h3>
                <textarea id="custom-csl-input" class="flex-grow p-4 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-base font-mono h-[calc(100vh-250px)]" placeholder="Paste your custom CSL XML here..."></textarea>
                <button id="apply-custom-csl" class="mt-4 px-4 py-2 bg-primary text-white rounded">Apply Custom CSL</button>
            </div>
        </div>
        
        <!-- Help Tab Content -->
        <div id="help-content" class="flex-grow overflow-auto hidden">
            <h2 class="text-xl font-medium mb-4">How to Use This Editor</h2>
            
            <div class="space-y-6">
                <section>
                    <h3 class="text-lg font-medium mb-2">Markdown Syntax</h3>
                    <p class="mb-2">This editor supports standard Markdown syntax:</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded"># Heading 1</code>, <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">## Heading 2</code>, etc. for headings</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">*italic*</code> or <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">_italic_</code> for italic text</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">**bold**</code> or <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">__bold__</code> for bold text</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">[link text](URL)</code> for links</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">![alt text](image-URL)</code> for images</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">1. Item</code> for ordered lists</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">- Item</code> or <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">* Item</code> for unordered lists</li>
                        <li><code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">```code block```</code> for code blocks</li>
                    </ul>
                </section>
                
                <section>
                    <h3 class="text-lg font-medium mb-2">Citations</h3>
                    <p class="mb-2">To add citations, follow these steps:</p>
                    <ol class="list-decimal pl-5 space-y-1">
                        <li>Go to the <strong>BibTeX</strong> tab and paste your BibTeX references</li>
                        <li>Click <strong>Parse BibTeX</strong> to load the references</li>
                        <li>Return to the <strong>Editor</strong> tab and add citations in your text using <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">[@key]</code> syntax</li>
                        <li>For multiple citations, use <code class="bg-gray-100 dark:bg-gray-800 px-1 rounded">[@key1; @key2]</code></li>
                    </ol>
                    <p class="mt-2">You can also click the <strong>Insert Citation</strong> button to add citations from a list of available references.</p>
                </section>
                
                <section>
                    <h3 class="text-lg font-medium mb-2">Citation Styles</h3>
                    <p class="mb-2">To change the citation style:</p>
                    <ol class="list-decimal pl-5 space-y-1">
                        <li>Go to the <strong>Citation Style</strong> tab</li>
                        <li>Select a predefined style from the dropdown menu</li>
                        <li>Or select <strong>Custom CSL</strong> and paste your own CSL XML</li>
                        <li>Click <strong>Apply Custom CSL</strong> to use your custom style</li>
                    </ol>
                    
                    <details class="mt-4 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <summary class="p-3 bg-gray-50 dark:bg-gray-800 cursor-pointer font-medium">Sample CSL XML</summary>
                        <div class="p-3 text-sm bg-gray-100 dark:bg-gray-900 overflow-auto">
                            <p class="mb-2">Here's a simple CSL XML example (Nature style):</p>
                            <pre class="text-xs border border-gray-300 dark:border-gray-700 p-2 bg-white dark:bg-gray-800 rounded overflow-auto">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;style xmlns="http://purl.org/net/xbiblio/csl" class="in-text" version="1.0" demote-non-dropping-particle="sort-only" default-locale="en-GB"&gt;
  &lt;info&gt;
    &lt;title&gt;Nature&lt;/title&gt;
    &lt;id&gt;http://www.zotero.org/styles/nature&lt;/id&gt;
    &lt;link href="http://www.zotero.org/styles/nature" rel="self"/&gt;
    &lt;link href="http://www.nature.com/nature/authors/gta/index.html#a5.4" rel="documentation"/&gt;
    &lt;author&gt;
      &lt;name&gt;Michael Berkowitz&lt;/name&gt;
      &lt;email&gt;mberkowi@gmu.edu&lt;/email&gt;
    &lt;/author&gt;
    &lt;category citation-format="numeric"/&gt;
    &lt;category field="science"/&gt;
    &lt;category field="generic-base"/&gt;
    &lt;issn&gt;0028-0836&lt;/issn&gt;
    &lt;eissn&gt;1476-4687&lt;/eissn&gt;
    &lt;updated&gt;2014-09-10T06:11:43+00:00&lt;/updated&gt;
    &lt;rights license="http://creativecommons.org/licenses/by-sa/3.0/"&gt;This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License&lt;/rights&gt;
  &lt;/info&gt;
  &lt;macro name="title"&gt;
    &lt;choose&gt;
      &lt;if type="bill book graphic legal_case legislation motion_picture report song" match="any"&gt;
        &lt;text variable="title" font-style="italic"/&gt;
      &lt;/if&gt;
      &lt;else&gt;
        &lt;text variable="title"/&gt;
      &lt;/else&gt;
    &lt;/choose&gt;
  &lt;/macro&gt;
  &lt;macro name="author"&gt;
    &lt;names variable="author"&gt;
      &lt;name sort-separator=", " delimiter=", " and="symbol" initialize-with=". " delimiter-precedes-last="never" name-as-sort-order="all"/&gt;
      &lt;label form="short" prefix=", "/&gt;
      &lt;et-al font-style="italic"/&gt;
    &lt;/names&gt;
  &lt;/macro&gt;
  &lt;macro name="access"&gt;
    &lt;choose&gt;
      &lt;if variable="volume"/&gt;
      &lt;else-if variable="DOI"&gt;
        &lt;text variable="DOI" prefix="doi:"/&gt;
      &lt;/else-if&gt;
    &lt;/choose&gt;
  &lt;/macro&gt;
  &lt;macro name="issuance"&gt;
    &lt;choose&gt;
      &lt;if type="bill book graphic legal_case legislation motion_picture report song thesis chapter paper-conference" match="any"&gt;
        &lt;group delimiter=", " prefix="(" suffix=")"&gt;
          &lt;text variable="publisher" form="long"/&gt;
          &lt;date variable="issued"&gt;
            &lt;date-part name="year"/&gt;
          &lt;/date&gt;
        &lt;/group&gt;
      &lt;/if&gt;
      &lt;else&gt;
        &lt;date prefix="(" suffix=")" variable="issued"&gt;
          &lt;date-part name="year"/&gt;
        &lt;/date&gt;
      &lt;/else&gt;
    &lt;/choose&gt;
  &lt;/macro&gt;
  &lt;citation collapse="citation-number"&gt;
    &lt;sort&gt;
      &lt;key variable="citation-number"/&gt;
    &lt;/sort&gt;
    &lt;layout vertical-align="sup" delimiter=","&gt;
      &lt;text variable="citation-number"/&gt;
    &lt;/layout&gt;
  &lt;/citation&gt;
  &lt;bibliography et-al-min="6" et-al-use-first="1" second-field-align="flush" entry-spacing="0" line-spacing="2"&gt;
    &lt;layout suffix="."&gt;
      &lt;text variable="citation-number" suffix="."/&gt;
      &lt;group delimiter=" "&gt;
        &lt;text macro="author" suffix="."/&gt;
        &lt;text macro="title" suffix="."/&gt;
        &lt;choose&gt;
          &lt;if type="chapter paper-conference" match="any"&gt;
            &lt;text term="in"/&gt;
          &lt;/if&gt;
        &lt;/choose&gt;
        &lt;text variable="container-title" font-style="italic" form="short"/&gt;
        &lt;text variable="volume" font-weight="bold" suffix=","/&gt;
        &lt;text variable="page"/&gt;
        &lt;text macro="issuance"/&gt;
        &lt;text macro="access"/&gt;
      &lt;/group&gt;
    &lt;/layout&gt;
  &lt;/bibliography&gt;
&lt;/style&gt;</pre>
                            <p class="mt-2">You can find more CSL styles on the <a href="https://github.com/citation-style-language/styles" target="_blank" class="text-primary underline">CSL GitHub repository</a> or use <a href="https://editor.citationstyles.org/visualEditor/" target="_blank" class="text-primary underline">CSL Editor</a> to create your own.</p>
                        </div>
                    </details>
                </section>
            </div>
        </div>
        
        <!-- Citation Picker Modal -->
        <div id="citation-picker-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-10">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-2xl w-full max-h-[80vh] overflow-auto">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-medium">Insert Citation</h3>
                    <button id="close-citation-picker" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="mb-4">
                    <input type="text" id="citation-search" class="w-full p-2 border border-gray-300 dark:border-gray-700 rounded-lg bg-white dark:bg-gray-800 text-base" placeholder="Search references...">
                </div>
                <div id="citation-list" class="divide-y divide-gray-200 dark:divide-gray-700"></div>
            </div>
        </div>
    </main>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // DOM Elements
        const tabs = {
            editor: document.getElementById('editor-tab'),
            bibtex: document.getElementById('bibtex-tab'),
            csl: document.getElementById('csl-tab'),
            help: document.getElementById('help-tab')
        };
        
        const contents = {
            editor: document.getElementById('editor-content'),
            bibtex: document.getElementById('bibtex-content'),
            csl: document.getElementById('csl-content'),
            help: document.getElementById('help-content')
        };
        
        const markdownEditor = document.getElementById('markdown-editor');
        const preview = document.getElementById('preview');
        const bibtexInput = document.getElementById('bibtex-input');
        const parseBtn = document.getElementById('parse-bibtex-btn');
        const bibtexStatus = document.getElementById('bibtex-status');
        const showReferencesBtn = document.getElementById('show-references-btn');
        const referencesModal = document.getElementById('references-modal');
        const referencesList = document.getElementById('references-list');
        const closeReferencesBtn = document.getElementById('close-references');
        const cslStyleSelect = document.getElementById('csl-style-select');
        const customCslContainer = document.getElementById('custom-csl-container');
        const customCslInput = document.getElementById('custom-csl-input');
        const applyCustomCslBtn = document.getElementById('apply-custom-csl');
        const availableCitations = document.getElementById('available-citations');
        const citationCount = document.getElementById('citation-count');
        const insertCitationBtn = document.getElementById('insert-citation');
        const citationPickerModal = document.getElementById('citation-picker-modal');
        const closeCitationPickerBtn = document.getElementById('close-citation-picker');
        const citationSearch = document.getElementById('citation-search');
        const citationList = document.getElementById('citation-list');
        
        // State variables
        let citations = {};
        let currentCsl = 'apa';
        let customCsl = null;
        
        // Tab switching
        function switchTab(tabName) {
            // Hide all tab contents
            Object.values(contents).forEach(content => {
                content.classList.add('hidden');
            });
            
            // Reset all tab buttons
            Object.values(tabs).forEach(tab => {
                tab.classList.remove('border-b-2', 'border-primary');
                tab.classList.add('text-gray-500', 'dark:text-gray-400');
            });
            
            // Show selected tab content and highlight button
            contents[tabName].classList.remove('hidden');
            tabs[tabName].classList.add('border-b-2', 'border-primary');
            tabs[tabName].classList.remove('text-gray-500', 'dark:text-gray-400');
        }
        
        // Event listeners for tab switching
        tabs.editor.addEventListener('click', () => switchTab('editor'));
        tabs.bibtex.addEventListener('click', () => switchTab('bibtex'));
        tabs.csl.addEventListener('click', () => switchTab('csl'));
        tabs.help.addEventListener('click', () => switchTab('help'));
        
        // Check if Citation.js is loaded and properly initialized
        function isCitationJsLoaded() {
            // First check if we've already successfully initialized
            if (window.citationJsLoaded === true) {
                return true;
            }
            
            // If we haven't explicitly tracked success, check if Cite exists
            if (typeof Cite !== 'undefined') {
                try {
                    // Try to initialize and test Citation.js
                    const testCite = new Cite();
                    window.citationJsLoaded = true;
                    return true;
                } catch (e) {
                    console.warn('Citation.js is available but not working properly:', e);
                    window.citationJsLoaded = false;
                    return false;
                }
            }
            
            console.warn('Citation.js is not loaded');
            return false;
        }
        
        // Manual BibTeX parsing fallback
        function parseSimpleBibtex(bibtex) {
            const entries = {};
            const regex = /@(\w+)\s*{\s*([^,]+),([^@]+)(?=@|\s*$)/g;
            
            let match;
            while ((match = regex.exec(bibtex + '@'))) {
                try {
                    const type = match[1].toLowerCase();
                    const key = match[2].trim();
                    const propertiesText = match[3];
                    
                    const entry = {
                        id: key,
                        type: type,
                        author: []
                    };
                    
                    // Parse individual fields
                    const fieldRegex = /\s*(\w+)\s*=\s*{([^}]*)}/g;
                    let fieldMatch;
                    
                    while ((fieldMatch = fieldRegex.exec(propertiesText))) {
                        const fieldName = fieldMatch[1].toLowerCase();
                        const fieldValue = fieldMatch[2].trim();
                        
                        if (fieldName === 'author') {
                            // Parse authors
                            const authors = fieldValue.split(' and ');
                            entry.author = authors.map(author => {
                                const nameParts = author.split(',');
                                if (nameParts.length > 1) {
                                    return {
                                        family: nameParts[0].trim(),
                                        given: nameParts[1].trim()
                                    };
                                } else {
                                    const parts = author.trim().split(' ');
                                    return {
                                        family: parts[parts.length - 1],
                                        given: parts.slice(0, -1).join(' ')
                                    };
                                }
                            });
                        } else if (fieldName === 'title') {
                            entry.title = fieldValue;
                        } else if (fieldName === 'year') {
                            entry.year = fieldValue;
                        } else if (fieldName === 'journal') {
                            entry.journal = fieldValue;
                            entry['container-title'] = fieldValue;
                        } else if (fieldName === 'publisher') {
                            entry.publisher = fieldValue;
                        } else if (fieldName === 'volume') {
                            entry.volume = fieldValue;
                        } else if (fieldName === 'number' || fieldName === 'issue') {
                            entry.issue = fieldValue;
                        } else if (fieldName === 'pages' || fieldName === 'page') {
                            entry.page = fieldValue;
                        } else if (fieldName === 'doi') {
                            entry.DOI = fieldValue;
                        } else if (fieldName === 'booktitle') {
                            entry['container-title'] = fieldValue;
                        } else {
                            entry[fieldName] = fieldValue;
                        }
                    }
                    
                    entries[key] = entry;
                } catch (e) {
                    console.error('Error parsing entry:', e);
                }
            }
            
            return Object.values(entries);
        }
        
        // Parse BibTeX references
        parseBtn.addEventListener('click', async () => {
            const bibtex = bibtexInput.value.trim();
            
            if (!bibtex) {
                bibtexStatus.textContent = 'Please enter BibTeX references.';
                bibtexStatus.className = 'mt-2 text-sm text-red-500';
                return;
            }
            
            bibtexStatus.textContent = 'Parsing references...';
            bibtexStatus.className = 'mt-2 text-sm text-blue-500';
            
            // Clear existing citations
            citations = {};
            
            try {
                let data = [];
                let usingFallback = false;
                
                // First try using Citation.js if available
                if (isCitationJsLoaded()) {
                    try {
                        const cite = new Cite(bibtex);
                        data = cite.data;
                        console.log("Successfully used Citation.js for parsing");
                    } catch (citationError) {
                        console.warn('Citation.js parsing failed, using fallback parser', citationError);
                        // Fall back to simple parser
                        data = parseSimpleBibtex(bibtex);
                        usingFallback = true;
                    }
                } else {
                    // Citation.js not loaded, attempt to initialize it again
                    if (typeof Cite !== 'undefined') {
                        console.log("Attempting to reinitialize Citation.js");
                        try {
                            // Try to create a minimal citation
                            const testCite = new Cite();
                            window.citationJsLoaded = true;
                            
                            // Now try again with the actual BibTeX
                            const cite = new Cite(bibtex);
                            data = cite.data;
                            console.log("Successfully reinitialized and used Citation.js");
                        } catch (e) {
                            console.error("Failed to reinitialize Citation.js:", e);
                            data = parseSimpleBibtex(bibtex);
                            usingFallback = true;
                        }
                    } else {
                        // Cite is completely unavailable
                        console.warn('Citation.js not loaded, using fallback parser');
                        data = parseSimpleBibtex(bibtex);
                        usingFallback = true;
                    }
                }
                
                // Process and store citation data
                data.forEach(item => {
                    if (item.id) {
                        citations[item.id] = item;
                    }
                });
                
                const citationKeys = Object.keys(citations);
                
                if (citationKeys.length === 0) {
                    bibtexStatus.textContent = 'No valid references found in the BibTeX. Check your format and try again.';
                    bibtexStatus.className = 'mt-2 text-sm text-yellow-500';
                    return;
                }
                
                let successMessage = `Successfully parsed ${citationKeys.length} references.`;
                if (usingFallback) {
                    successMessage += ' Using simplified parser - custom CSL XML functionality may be limited.';
                    bibtexStatus.className = 'mt-2 text-sm text-yellow-500';
                } else {
                    bibtexStatus.className = 'mt-2 text-sm text-green-500';
                }
                bibtexStatus.textContent = successMessage;
                
                // Update references count and enable references button
                citationCount.textContent = citationKeys.length;
                availableCitations.classList.remove('hidden');
                showReferencesBtn.classList.remove('hidden');
                insertCitationBtn.disabled = false;
                
                // Populate references modal
                populateReferencesModal();
                
                // Update preview with citations
                updatePreview();
                
                // Switch to editor tab
                switchTab('editor');
                
            } catch (error) {
                console.error('Error parsing BibTeX:', error);
                bibtexStatus.textContent = `Error parsing BibTeX: ${error.message || 'Unknown error'}. Please check your BibTeX format.`;
                bibtexStatus.className = 'mt-2 text-sm text-red-500';
            }
        });
        
        // Populate references modal
        function populateReferencesModal() {
            referencesList.innerHTML = '';
            
            Object.entries(citations).forEach(([key, citation]) => {
                const referenceItem = document.createElement('div');
                referenceItem.className = 'py-3';
                
                const title = citation.title || 'Untitled';
                const authors = getFormattedAuthors(citation);
                const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                const source = citation.container_title || citation['container-title'] || citation.journal || citation.publisher || '';
                
                referenceItem.innerHTML = `
                    <div class="flex justify-between">
                        <div>
                            <p class="font-medium">${title}</p>
                            <p class="text-sm text-gray-600 dark:text-gray-400">${authors} (${year})</p>
                            ${source ? `<p class="text-sm italic">${source}</p>` : ''}
                        </div>
                        <div class="text-sm bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded self-start">
                            [@${key}]
                        </div>
                    </div>
                `;
                
                referencesList.appendChild(referenceItem);
            });
        }
        
        // Format author names
        function getFormattedAuthors(citation) {
            if (!citation.author || !Array.isArray(citation.author) || citation.author.length === 0) {
                return 'Unknown Author';
            }
            
            if (citation.author.length === 1) {
                const author = citation.author[0];
                return author.family ? `${author.family}, ${author.given || ''}`.trim() : (author.literal || 'Unknown Author');
            }
            
            if (citation.author.length === 2) {
                const author1 = citation.author[0];
                const author2 = citation.author[1];
                const name1 = author1.family ? `${author1.family}` : (author1.literal || '');
                const name2 = author2.family ? `${author2.family}` : (author2.literal || '');
                return `${name1} & ${name2}`;
            }
            
            const firstAuthor = citation.author[0];
            const firstName = firstAuthor.family ? `${firstAuthor.family}` : (firstAuthor.literal || '');
            return `${firstName} et al.`;
        }
        
        // Get full formatted authors list
        function getFullFormattedAuthors(citation) {
            if (!citation.author || !Array.isArray(citation.author) || citation.author.length === 0) {
                return 'Unknown Author';
            }
            
            return citation.author.map((author, index) => {
                if (index === 0) {
                    // First author: Last, First
                    return author.family ? `${author.family}, ${author.given || ''}`.trim() : (author.literal || 'Unknown Author');
                } else {
                    // Subsequent authors: First Last
                    return author.family ? `${author.given || ''} ${author.family}`.trim() : (author.literal || 'Unknown Author');
                }
            }).join(', ').replace(/, ([^,]*)$/, ', & $1'); // Replace last comma with "&"
        }
        
        // Show references modal
        showReferencesBtn.addEventListener('click', () => {
            referencesModal.classList.remove('hidden');
        });
        
        // Close references modal
        closeReferencesBtn.addEventListener('click', () => {
            referencesModal.classList.add('hidden');
        });
        
        // Close modal when clicking outside
        referencesModal.addEventListener('click', (e) => {
            if (e.target === referencesModal) {
                referencesModal.classList.add('hidden');
            }
        });
        
        // Handle CSL style selection
        cslStyleSelect.addEventListener('change', function() {
            currentCsl = this.value;
            
            if (currentCsl === 'custom') {
                customCslContainer.classList.remove('hidden');
            } else {
                customCslContainer.classList.add('hidden');
                updatePreview();
            }
        });
        
        // New implementation of custom CSL application
        applyCustomCslBtn.addEventListener('click', function() {
            // Get the custom CSL XML
            customCsl = customCslInput.value.trim();
            if (!customCsl) {
                alert("请输入 CSL XML 数据");
                return;
            }
            
            try {
                // 验证 CSL XML 格式
                const parser = new DOMParser();
                const doc = parser.parseFromString(customCsl, "application/xml");
                const parseError = doc.querySelector("parsererror");
                
                if (parseError) {
                    throw new Error("无效的 XML 格式");
                }
                
                // 重置现有的 CSL 引擎
                cslEngine = null;
                
                // 准备新的 CSL 引擎
                if (typeof CSL !== 'undefined') {
                    try {
                        // 记录第一步: 尝试初始化引擎
                        console.log("正在初始化 CSL 引擎...");
                        
                        // 创建系统对象
                        const sys = {
                            retrieveLocale: function(lang) {
                                console.log("获取语言区域:", lang);
                                // 使用我们存储的英语区域定义
                                return window.CSL_LOCALES["en-US"] || 
                                    '<locale xmlns="http://purl.org/net/xbiblio/csl" version="1.0" xml:lang="en-US"></locale>';
                            },
                            retrieveItem: function(id) {
                                console.log("获取条目:", id);
                                return citations[id] || null;
                            }
                        };
                        
                        // 初始化 CSL 引擎
                        console.log("使用自定义样式创建 CSL 引擎");
                        cslEngine = new CSL.Engine(sys, customCsl);
                        
                        // 测试引擎是否正常工作
                        console.log("测试 CSL 引擎...");
                        
                        // 使用第一个引用测试
                        const testId = Object.keys(citations)[0];
                        if (testId) {
                            cslEngine.updateItems([testId]);
                            
                            // 测试引文处理
                            const citation = {
                                citationItems: [{ id: testId }],
                                properties: { noteIndex: 1 }
                            };
                            
                            const result = cslEngine.processCitationCluster(citation, [], []);
                            console.log("引文测试结果:", result);
                            
                            // 测试参考文献
                            const bibResult = cslEngine.makeBibliography();
                            console.log("参考文献测试结果:", bibResult);
                            
                            if (result && bibResult) {
                                console.log("CSL 引擎已成功初始化并测试通过");
                            }
                        }
                    } catch (e) {
                        console.error("CSL 引擎初始化错误:", e);
                        cslEngine = null;
                        throw new Error("无法初始化 CSL 引擎: " + e.message);
                    }
                } else {
                    console.error("CSL 库未加载");
                    throw new Error("CSL 库未加载，无法应用自定义样式");
                }
                
                // 显示成功状态
                const cslStatus = document.createElement('div');
                cslStatus.className = 'mt-2 text-sm text-green-500';
                cslStatus.textContent = '自定义 CSL 已应用! 返回编辑器标签页查看效果。';
                customCslContainer.appendChild(cslStatus);
                
                // 3秒后移除状态信息
                setTimeout(() => {
                    if (cslStatus.parentNode) {
                        cslStatus.parentNode.removeChild(cslStatus);
                    }
                }, 3000);
                
                // 更新预览
                updatePreview();
                
                // 自动切换到编辑器标签页
                switchTab('editor');
                
            } catch (error) {
                console.error("自定义 CSL 错误:", error);
                
                // 显示错误信息
                const cslError = document.createElement('div');
                cslError.className = 'mt-2 text-sm text-red-500';
                cslError.textContent = '错误: ' + error.message;
                customCslContainer.appendChild(cslError);
                
                // 3秒后移除错误信息
                setTimeout(() => {
                    if (cslError.parentNode) {
                        cslError.parentNode.removeChild(cslError);
                    }
                }, 5000);
            }
        });
        
        // Insert citation button
        insertCitationBtn.addEventListener('click', () => {
            populateCitationPicker();
            citationPickerModal.classList.remove('hidden');
        });
        
        // Close citation picker
        closeCitationPickerBtn.addEventListener('click', () => {
            citationPickerModal.classList.add('hidden');
        });
        
        // Close citation picker when clicking outside
        citationPickerModal.addEventListener('click', (e) => {
            if (e.target === citationPickerModal) {
                citationPickerModal.classList.add('hidden');
            }
        });
        
        // Search in citation picker
        citationSearch.addEventListener('input', () => {
            const searchTerm = citationSearch.value.toLowerCase();
            populateCitationPicker(searchTerm);
        });
        
        // Populate citation picker
        function populateCitationPicker(searchTerm = '') {
            citationList.innerHTML = '';
            
            Object.entries(citations).forEach(([key, citation]) => {
                // Skip if doesn't match search
                const title = (citation.title || 'Untitled').toLowerCase();
                const authors = getFormattedAuthors(citation).toLowerCase();
                
                if (searchTerm && !title.includes(searchTerm) && !authors.includes(searchTerm) && !key.toLowerCase().includes(searchTerm)) {
                    return;
                }
                
                const citationItem = document.createElement('div');
                citationItem.className = 'py-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 px-2 rounded';
                
                const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                const source = citation.container_title || citation['container-title'] || citation.journal || citation.publisher || '';
                
                citationItem.innerHTML = `
                    <p class="font-medium">${citation.title || 'Untitled'}</p>
                    <p class="text-sm text-gray-600 dark:text-gray-400">${getFormattedAuthors(citation)} (${year})</p>
                    ${source ? `<p class="text-sm italic">${source}</p>` : ''}
                    <div class="text-sm text-primary font-medium mt-1">[@${key}]</div>
                `;
                
                citationItem.addEventListener('click', () => {
                    insertCitationInEditor(key);
                    citationPickerModal.classList.add('hidden');
                });
                
                citationList.appendChild(citationItem);
            });
        }
        
        // Insert citation into editor
        function insertCitationInEditor(key) {
            const editor = document.getElementById('markdown-editor');
            const cursorPos = editor.selectionStart;
            const textBefore = editor.value.substring(0, cursorPos);
            const textAfter = editor.value.substring(cursorPos, editor.value.length);
            
            editor.value = textBefore + `[@${key}]` + textAfter;
            editor.focus();
            
            // Set cursor position after the inserted citation
            const newCursorPos = cursorPos + `[@${key}]`.length;
            editor.setSelectionRange(newCursorPos, newCursorPos);
            
            // Update preview
            updatePreview();
        }
        
        // Global CSL engine for custom styles
        let cslEngine = null;
        
        // Format citation in text using direct CSL approach
        function formatCitation(key) {
            const citation = citations[key];
            if (!citation) return `[@${key}]`; // Not found, return original
            
            // If using custom CSL and CSL.Engine is available, use it directly
            if (currentCsl === 'custom' && customCsl && typeof CSL !== 'undefined') {
                try {
                    console.log("处理引用:", key, "使用自定义 CSL");
                    
                    // Initialize the CSL engine if not already done
                    if (!cslEngine) {
                        console.log("创建新的 CSL 引擎");
                        
                        // System for retrieving items and locales
                        const citationSystem = {
                            retrieveLocale: function(lang) {
                                console.log("请求区域:", lang);
                                return window.CSL_LOCALES["en-US"] || 
                                    '<locale xmlns="http://purl.org/net/xbiblio/csl" version="1.0" xml:lang="en-US"></locale>';
                            },
                            retrieveItem: function(id) {
                                console.log("获取引用项:", id);
                                const item = citations[id] || null;
                                if (item) {
                                    // 规范化引用项数据
                                    if (item.year && !item.issued) {
                                        item.issued = { 'date-parts': [[item.year]] };
                                    }
                                    // 确保需要的属性存在
                                    if (!item.type) item.type = "article-journal";
                                    
                                    console.log("返回引用项:", JSON.stringify(item).substring(0, 100) + "...");
                                }
                                return item;
                            }
                        };
                        
                        try {
                            // 创建 CSL 引擎
                            cslEngine = new CSL.Engine(citationSystem, customCsl);
                            console.log("CSL 引擎初始化成功");
                        } catch (engineErr) {
                            console.error("创建 CSL 引擎失败:", engineErr);
                            throw engineErr;
                        }
                    }
                    
                    // 使用引擎格式化引用
                    try {
                        // 确保引擎已更新引用项
                        cslEngine.updateItems([key]);
                        
                        // 创建引用描述对象
                        const citation = {
                            citationItems: [{ id: key }],
                            properties: { noteIndex: 1 }
                        };
                        
                        console.log("处理引用项:", citation);
                        
                        // 获取格式化后的引用文本
                        const result = cslEngine.processCitationCluster(citation, [], []);
                        console.log("引用处理结果:", result);
                        
                        if (result && result[1] && result[1].length > 0 && result[1][0] && result[1][0][1]) {
                            const formattedText = result[1][0][1];
                            console.log("格式化后的引用:", formattedText);
                            return formattedText; // 返回格式化后的引用文本
                        } else {
                            console.warn("引用处理返回空结果");
                        }
                    } catch (citationError) {
                        console.error("CSL 引用处理错误:", citationError);
                    }
                } catch (e) {
                    console.error("设置 CSL 引擎错误:", e);
                }
            }
            
            // If custom CSL failed or not using custom CSL, fall back to built-in formatting
            if (currentCsl === 'custom' && customCsl) {
                console.warn("Custom CSL processing failed, falling back to built-in format");
            }
            
            // Default formatting for predefined styles or if custom CSL fails
            let result = '';
            
            switch (currentCsl) {
                case 'apa':
                    // APA style: (Author, Year)
                    const author = citation.author?.[0]?.family || 'Unknown';
                    const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                    result = `(${author}, ${year})`;
                    break;
                    
                case 'mla':
                    // MLA style: (Author Page)
                    const mlaAuthor = citation.author?.[0]?.family || 'Unknown';
                    result = `(${mlaAuthor})`;
                    break;
                    
                case 'chicago':
                    // Chicago style: (Author Year)
                    const chicagoAuthor = citation.author?.[0]?.family || 'Unknown';
                    const chicagoYear = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                    result = `(${chicagoAuthor} ${chicagoYear})`;
                    break;
                    
                case 'ieee':
                    // IEEE style: [1], [2], etc.
                    const keys = Object.keys(citations);
                    const index = keys.indexOf(key) + 1;
                    result = `[${index}]`;
                    break;
                    
                case 'harvard':
                    // Harvard style: (Author, Year)
                    const harvardAuthor = citation.author?.[0]?.family || 'Unknown';
                    const harvardYear = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                    result = `(${harvardAuthor}, ${harvardYear})`;
                    break;
                    
                case 'vancouver':
                    // Vancouver style: (1), (2), etc.
                    const vanKeys = Object.keys(citations);
                    const vanIndex = vanKeys.indexOf(key) + 1;
                    result = `(${vanIndex})`;
                    break;
                    
                case 'custom':
                    // Fallback for custom CSL when direct approach fails
                    const customAuthor = citation.author?.[0]?.family || 'Unknown';
                    const customYear = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                    result = `(${customAuthor}, ${customYear})`;
                    break;
                    
                default:
                    // Default format
                    result = `[@${key}]`;
            }
            
            return result;
        }
        
        // Process citations in text
        function processCitations(text) {
            if (Object.keys(citations).length === 0) return text;
            
            // Handle grouped citations [@key1; @key2]
            let processed = text.replace(/\[@([^;\]]+)(?:;\s*@([^;\]]+))*\]/g, (match) => {
                // Extract all keys from the group
                const keys = match.match(/@([^;\]]+)/g).map(k => k.substring(1));
                
                if (keys.length === 1) {
                    // Single citation
                    return formatCitation(keys[0]);
                } else {
                    // Multiple citations
                    switch (currentCsl) {
                        case 'apa':
                        case 'harvard':
                            // Format: (Author1, Year; Author2, Year)
                            const formattedCitations = keys.map(key => {
                                const citation = citations[key];
                                if (!citation) return key;
                                const author = citation.author?.[0]?.family || 'Unknown';
                                const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                                return `${author}, ${year}`;
                            });
                            return `(${formattedCitations.join('; ')})`;
                            
                        case 'ieee':
                            // Format: [1, 2, 3]
                            const ieeeIndices = keys.map(key => {
                                const allKeys = Object.keys(citations);
                                return allKeys.indexOf(key) + 1;
                            }).sort((a, b) => a - b);
                            return `[${ieeeIndices.join(', ')}]`;
                            
                        case 'vancouver':
                            // Format: (1, 2, 3)
                            const vanIndices = keys.map(key => {
                                const allKeys = Object.keys(citations);
                                return allKeys.indexOf(key) + 1;
                            }).sort((a, b) => a - b);
                            return `(${vanIndices.join(', ')})`;
                            
                        default:
                            // Default format for other styles
                            return match;
                    }
                }
            });
            
            // Handle individual citations [@key]
            processed = processed.replace(/\[@([^\]]+)\]/g, (match, key) => {
                return formatCitation(key);
            });
            
            return processed;
        }
        
        // Generate bibliography with improved custom CSL support
        function generateBibliography() {
            if (Object.keys(citations).length === 0) return '';
            
            // If using custom CSL and Citeproc-js is available, use it directly
            if (currentCsl === 'custom' && customCsl && typeof CSL !== 'undefined') {
                try {
                    console.log("正在生成参考文献 (使用自定义 CSL)...");
                    
                    // Initialize the CSL engine if not already done
                    if (!cslEngine) {
                        console.log("为参考文献创建新的 CSL 引擎...");
                        
                        // System for retrieving items and locales
                        const citationSystem = {
                            retrieveLocale: function(lang) {
                                console.log("参考文献 - 获取区域:", lang);
                                return window.CSL_LOCALES["en-US"] || 
                                    '<locale xmlns="http://purl.org/net/xbiblio/csl" version="1.0" xml:lang="en-US"></locale>';
                            },
                            retrieveItem: function(id) {
                                console.log("参考文献 - 获取条目:", id);
                                const item = citations[id] || null;
                                if (item) {
                                    // 规范化引用项数据
                                    if (item.year && !item.issued) {
                                        item.issued = { 'date-parts': [[item.year]] };
                                    }
                                    // 确保需要的属性存在
                                    if (!item.type) item.type = "article-journal";
                                }
                                return item;
                            }
                        };
                        
                        try {
                            // 创建 CSL 引擎
                            cslEngine = new CSL.Engine(citationSystem, customCsl);
                            console.log("参考文献 - CSL 引擎初始化成功");
                        } catch (engineErr) {
                            console.error("参考文献 - 创建 CSL 引擎失败:", engineErr);
                            throw engineErr;
                        }
                    }
                    
                    // 获取所有引用键并更新处理器
                    const keys = Object.keys(citations);
                    console.log("参考文献 - 更新条目:", keys);
                    cslEngine.updateItems(keys);
                    
                    // 生成参考文献
                    try {
                        console.log("参考文献 - 创建参考文献...");
                        const result = cslEngine.makeBibliography();
                        console.log("参考文献结果:", result);
                        
                        if (result && result[1] && result[1].length > 0) {
                            // 转换参考文献项为 markdown 格式
                            let bibliography = '## References\n\n';
                            
                            result[1].forEach((entry, index) => {
                                // 删除 HTML 标签
                                let plainText = entry.replace(/<[^>]*>/g, ' ')
                                    .replace(/\s+/g, ' ')
                                    .trim();
                                
                                // 打印调试信息
                                if (index < 3) {
                                    console.log(`参考文献项 ${index + 1}:`, plainText);
                                }
                                
                                bibliography += plainText + '\n\n';
                            });
                            
                            console.log("参考文献生成成功");
                            return bibliography;
                        } else {
                            console.warn("参考文献结果为空");
                        }
                    } catch (bibError) {
                        console.error("参考文献 - 生成错误:", bibError);
                    }
                } catch (e) {
                    console.error("参考文献 - 设置 CSL 引擎错误:", e);
                }
            }
            
            // Default fallback bibliography generation
            let bibliography = '## References\n\n';
            
            const sortedCitations = Object.entries(citations).sort((a, b) => {
                // Sort by first author's last name
                const authorA = a[1].author?.[0]?.family || 'ZZZ';
                const authorB = b[1].author?.[0]?.family || 'ZZZ';
                return authorA.localeCompare(authorB);
            });
            
            switch (currentCsl) {
                case 'ieee':
                case 'vancouver':
                    // Numerical styles - sort by order of appearance
                    sortedCitations.forEach(([key, citation], index) => {
                        const number = index + 1;
                        const authors = getFormattedAuthors(citation);
                        const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                        const title = citation.title || 'Untitled';
                        const source = citation.container_title || citation['container-title'] || citation.journal || '';
                        const volume = citation.volume ? `vol. ${citation.volume}` : '';
                        const issue = citation.issue ? `no. ${citation.issue}` : '';
                        const pages = citation.page || '';
                        
                        if (currentCsl === 'ieee') {
                            bibliography += `[${number}] ${authors}, "${title}," `;
                            if (source) bibliography += `*${source}*, `;
                            if (volume) bibliography += `${volume}, `;
                            if (issue) bibliography += `${issue}, `;
                            if (pages) bibliography += `pp. ${pages}, `;
                            bibliography += `${year}.\n\n`;
                        } else {
                            // Vancouver
                            bibliography += `(${number}) ${authors}. ${title}. `;
                            if (source) bibliography += `${source}. `;
                            if (volume) bibliography += `${volume}`;
                            if (issue) bibliography += `(${issue})`;
                            if (volume || issue) bibliography += `:`;
                            if (pages) bibliography += `${pages}. `;
                            bibliography += `${year}.\n\n`;
                        }
                    });
                    break;
                    
                default:
                    // Author-date styles
                    sortedCitations.forEach(([key, citation]) => {
                        const authors = getFullFormattedAuthors(citation);
                        const year = citation.issued?.['date-parts']?.[0]?.[0] || citation.year || 'n.d.';
                        const title = citation.title || 'Untitled';
                        const source = citation.container_title || citation['container-title'] || citation.journal || '';
                        const publisher = citation.publisher || '';
                        const volume = citation.volume || '';
                        const issue = citation.issue || '';
                        const pages = citation.page || '';
                        const doi = citation.DOI || citation.doi || '';
                        
                        if (currentCsl === 'apa' || currentCsl === 'harvard') {
                            bibliography += `${authors} (${year}). ${title}. `;
                            if (source) bibliography += `*${source}*`;
                            if (volume) bibliography += `, ${volume}`;
                            if (issue) bibliography += `(${issue})`;
                            if (pages) bibliography += `, ${pages}`;
                            bibliography += `. `;
                            if (publisher) bibliography += `${publisher}. `;
                            if (doi) bibliography += `https://doi.org/${doi}`;
                            bibliography += `\n\n`;
                        } else if (currentCsl === 'mla') {
                            bibliography += `${authors}. "${title}." `;
                            if (source) bibliography += `*${source}*, `;
                            if (volume) bibliography += `vol. ${volume}, `;
                            if (issue) bibliography += `no. ${issue}, `;
                            bibliography += `${year}, `;
                            if (pages) bibliography += `pp. ${pages}. `;
                            if (doi) bibliography += `DOI: ${doi}`;
                            bibliography += `\n\n`;
                        } else if (currentCsl === 'chicago') {
                            bibliography += `${authors}. ${year}. "${title}." `;
                            if (source) bibliography += `*${source}* `;
                            if (volume) bibliography += `${volume}`;
                            if (issue) bibliography += ` (${issue})`;
                            if (volume || issue) bibliography += `: `;
                            if (pages) bibliography += `${pages}. `;
                            if (publisher) bibliography += `${publisher}. `;
                            if (doi) bibliography += `https://doi.org/${doi}`;
                            bibliography += `\n\n`;
                        } else {
                            // Generic format for other styles or custom
                            bibliography += `${authors}. (${year}). ${title}. `;
                            if (source) bibliography += `*${source}*. `;
                            if (volume) bibliography += `${volume}`;
                            if (issue) bibliography += `(${issue})`;
                            if (pages) bibliography += `:${pages}`;
                            if (volume || issue || pages) bibliography += `. `;
                            if (doi) bibliography += `https://doi.org/${doi}`;
                            bibliography += `\n\n`;
                        }
                    });
            }
            
            return bibliography;
        }
        
        // Update preview when markdown changes
        markdownEditor.addEventListener('input', updatePreview);
        
        // Simple Markdown parser for fallback
        function simpleMarkdownParser(text) {
            // Safety check
            if (!text) return '';
            
            // Convert headings
            text = text.replace(/^# (.*?)$/gm, '<h1>$1</h1>');
            text = text.replace(/^## (.*?)$/gm, '<h2>$1</h2>');
            text = text.replace(/^### (.*?)$/gm, '<h3>$1</h3>');
            
            // Convert bold and italic
            text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');
            
            // Convert links
            text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
            
            // Convert lists
            let inList = false;
            const lines = text.split('\n');
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].match(/^- /)) {
                    if (!inList) {
                        lines[i] = '<ul><li>' + lines[i].substring(2) + '</li>';
                        inList = true;
                    } else {
                        lines[i] = '<li>' + lines[i].substring(2) + '</li>';
                    }
                    
                    // Check if next line is not a list item
                    if (!lines[i+1] || !lines[i+1].match(/^- /)) {
                        lines[i] += '</ul>';
                        inList = false;
                    }
                }
            }
            text = lines.join('\n');
            
            // Convert paragraphs
            text = text.replace(/\n\n/g, '</p><p>');
            
            // Wrap in paragraphs
            text = '<p>' + text + '</p>';
            
            return text;
        }
        
        // Update preview with rendered markdown and processed citations
        function updatePreview() {
            let markdown = markdownEditor.value;
            
            try {
                // Process citations if we have any
                if (Object.keys(citations).length > 0) {
                    markdown = processCitations(markdown);
                    
                    // Add bibliography if it doesn't already exist
                    if (!markdown.includes('## References') && !markdown.includes('# References')) {
                        markdown += '\n\n' + generateBibliography();
                    }
                }
                
                // Try different rendering methods
                let rendered = '';
                
                // First try marked.js
                if (typeof marked !== 'undefined') {
                    try {
                        rendered = marked.parse(markdown);
                        console.log("Using marked.js for rendering");
                    } catch (markedError) {
                        console.warn("marked.js error:", markedError);
                        // Will fall through to alternatives
                    }
                }
                
                // If marked.js failed or isn't loaded, use our simple parser
                if (!rendered) {
                    console.log("Using simple markdown parser");
                    rendered = simpleMarkdownParser(markdown);
                }
                
                // Sanitize HTML if DOMPurify is available
                if (typeof DOMPurify !== 'undefined') {
                    rendered = DOMPurify.sanitize(rendered);
                }
                
                // Update the preview
                preview.innerHTML = rendered;
            } catch (e) {
                console.error('Error updating preview:', e);
                
                // Fallback to plain text with minimal HTML formatting
                preview.innerHTML = `<p class="text-red-500">Error rendering preview: ${e.message}</p>
                                    <pre class="mt-4 p-2 bg-gray-100 dark:bg-gray-800 rounded overflow-auto">${markdown.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>`;
            }
        }
        
        // Initialize the app with some sample content
        window.addEventListener('DOMContentLoaded', function() {
            // Sample markdown with citations
            markdownEditor.value = `# Sample Academic Document

## Introduction

This is a sample document that demonstrates the citation capabilities of this editor. According to Smith [@smith2020], markdown is excellent for academic writing.

Multiple researchers [@jones2019; @wilson2021] have confirmed these findings.

## Discussion

The advantages of using markdown for academic writing include simplicity and portability [@smith2020].

## Conclusion

As we have seen in the literature [@smith2020; @jones2019; @wilson2021], markdown provides numerous benefits for scholarly communication.`;

            // Sample BibTeX with simpler format to ensure compatibility
            bibtexInput.value = `@article{smith2020,
  author = {Smith, John},
  title = {Markdown for Academic Writing},
  journal = {Journal of Documentation},
  volume = {45},
  page={19},
  year = {2020}
}

@book{jones2019,
  author = {Jones, Sarah and Brown, David},
  title = {Modern Documentation Systems},
  publisher = {Tech Publishing},
  year = {2019}
}

@inproceedings{wilson2021,
  author = {Wilson, Emma},
  title = {Markdown in Academic Writing},
  booktitle = {Proceedings of the International Conference on Documentation},
  year = {2021}
}`;

            // Disable insert citation button until references are loaded
            insertCitationBtn.disabled = true;
            
            // Update the preview
            updatePreview();
        });
    </script>
</body>
</html>


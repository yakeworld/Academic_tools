<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Academic Search</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/x2js@3.4.4/x2js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                    }
                }
            }
        }
        
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
        
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        
        // Initialize marked for markdown rendering
        marked.setOptions({
            breaks: true,
            gfm: true
        });
    </script>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen p-4 pb-20">
    <div class="container mx-auto max-w-4xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-primary mb-2">JavaScript arXiv Search</h1>
            <p class="text-gray-600 dark:text-gray-400">Search academic papers in physics, mathematics, computer science, and more</p>
        </header>
        
        <!-- Selection Toolbar (Fixed at bottom) -->
        <div id="selection-toolbar" class="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 shadow-md p-3 border-t border-gray-200 dark:border-gray-700 hidden z-50" style="margin-bottom: env(safe-area-inset-bottom, 0);">
            <div class="container mx-auto max-w-4xl flex justify-between items-center">
                <div class="text-sm flex items-center">
                    <span id="selected-count">0</span> papers selected
                    <button id="clear-selection" class="ml-2 text-primary hover:underline text-xs">Clear selection</button>
                    <button id="merge-refs" class="ml-3 text-primary hover:underline text-xs flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                        </svg>
                        Add to merged refs (<span id="merged-count">0</span>)
                    </button>
                    <button id="clear-merged-refs" class="ml-2 text-primary hover:underline text-xs">Clear merged refs</button>
                </div>
                <div class="flex space-x-2">
                    <button id="export-bibtex" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        Export Selected
                    </button>
                    <button id="export-merged-bibtex" class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                        </svg>
                        Export Merged (<span id="merged-count-button">0</span>)
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Merged References Notification -->
        <div id="merge-notification" class="fixed bottom-16 right-4 bg-green-600 text-white px-4 py-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-500 z-50">
            <p class="text-sm font-medium">References added to merged list</p>
        </div>
        
        <!-- Paper Polishing Button removed from here - will add to main interface -->
        
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-md p-6 mb-8">
            <form id="search-form" class="space-y-4">
                <div class="flex items-center justify-center mb-4">
                    <div class="space-y-2">
                    <div class="flex flex-wrap gap-2">
                        <div class="flex items-center">
                            <input type="checkbox" id="arxiv-checkbox" class="h-4 w-4 text-primary border-gray-300 rounded focus:ring-primary" checked>
                            <label for="arxiv-checkbox" class="ml-2 text-sm font-medium">arXiv</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="pubmed-checkbox" class="h-4 w-4 text-primary border-gray-300 rounded focus:ring-primary">
                            <label for="pubmed-checkbox" class="ml-2 text-sm font-medium">PubMed</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="semantic-checkbox" class="h-4 w-4 text-primary border-gray-300 rounded focus:ring-primary">
                            <label for="semantic-checkbox" class="ml-2 text-sm font-medium">Semantic Scholar</label>
                        </div>
                        <div class="flex items-center ml-4">
                            <button type="button" id="select-all" class="text-sm text-primary hover:underline">
                                Select All
                            </button>
                            <span class="mx-2 text-gray-500">|</span>
                            <button type="button" id="clear-all" class="text-sm text-primary hover:underline">
                                Clear All
                            </button>
                        </div>
                    </div>
                    <div id="database-message" class="text-xs text-gray-500 dark:text-gray-400 italic">
                        Searching in arXiv database only
                    </div>
                </div>
                </div>
                
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label for="query" class="block text-sm font-medium">Search Query</label>
                        <button type="button" id="extract-keywords-btn" class="text-sm text-primary hover:underline flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                            </svg>
                            Extract Keywords
                        </button>
                    </div>
                    <input 
                        type="text" 
                        id="query" 
                        placeholder="Enter keywords, authors, or topics (separate multiple keywords with semicolons)..." 
                        class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 text-base"
                        required
                    >
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">For multiple searches, separate with semicolons (e.g., "machine learning; deep learning")</p>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="results-count" class="block text-sm font-medium mb-2">Results Count</label>
                        <select 
                            id="results-count" 
                            class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 text-base"
                        >
                            <option value="5">5 results</option>
                            <option value="10" selected>10 results</option>
                            <option value="20">20 results</option>
                            <option value="50">50 results</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="date-range" class="block text-sm font-medium mb-2">Publication Years</label>
                        <select 
                            id="date-range" 
                            class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 text-base"
                        >
                            <option value="all" selected>All Years</option>
                            <option value="1">Last Year</option>
                            <option value="5">Last 5 Years</option>
                            <option value="10">Last 10 Years</option>
                        </select>
                    </div>
                </div>
                
                <div class="pt-2 grid grid-cols-1 md:grid-cols-4 gap-2">
                    <button 
                        type="submit" 
                        id="search-button"
                        class="md:col-span-3 bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors flex items-center justify-center"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                        <span id="search-button-text">Search arXiv</span>
                    </button>
                    
                    <button 
                        type="button" 
                        id="polish-paper-button"
                        class="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                        </svg>
                        <span>Polish Paper</span>
                    </button>
                </div>
            </form>
        </div>
        
        <div id="loading" class="hidden text-center py-6">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
            <p class="mt-2 text-gray-600 dark:text-gray-400">Searching arXiv database...</p>
        </div>
        
        <div id="error-container" class="hidden bg-red-100 dark:bg-red-900 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-200 p-4 rounded-lg mb-6">
            <p id="error-message">An error occurred during the search.</p>
        </div>
        
        <div id="results-container" class="hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">Search Results</h2>
                <div id="result-stats" class="text-sm text-gray-600 dark:text-gray-400">
                    Found <span id="total-results">0</span> results
                </div>
            </div>
            
            <div id="results-list" class="space-y-6">
                <!-- Results will be populated here -->
            </div>
            
            <!-- Pagination UI -->
            <div id="pagination-container" class="flex justify-center items-center space-x-2 mt-8 mb-8">
                <button id="prev-page" class="px-4 py-2 bg-primary text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    Previous
                </button>
                <div class="text-sm">
                    Page <span id="current-page">1</span> of <span id="total-pages">1</span>
                </div>
                <button id="next-page" class="px-4 py-2 bg-primary text-white rounded-lg disabled:opacity-50 disabled:cursor-not-allowed flex items-center">
                    Next
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>
            

        </div>
        
        <div id="no-results" class="hidden text-center py-8">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <p class="text-lg text-gray-600 dark:text-gray-400">No results found for your search terms.</p>
            <p class="mt-2 text-gray-600 dark:text-gray-400">Try different keywords or broaden your search.</p>
        </div>
        

        
        <!-- BibTeX Export Modal -->
        <div id="bibtex-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h3 class="text-lg font-semibold">BibTeX Export</h3>
                    <button id="close-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="p-4 overflow-auto flex-grow">
                    <pre id="bibtex-content" class="bg-gray-100 dark:bg-gray-900 p-4 rounded-lg overflow-auto text-xs h-full whitespace-pre-wrap"></pre>
                </div>
                <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-between">
                    <span class="text-sm text-gray-500 dark:text-gray-400"><span id="bibtex-count">0</span> citations exported</span>
                    <button id="copy-bibtex" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                        </svg>
                        Copy to Clipboard
                    </button>
                </div>
            </div>
        </div>

        <!-- Keyword Extraction Modal -->
        <div id="extract-keywords-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h3 class="text-lg font-semibold">Extract Keywords</h3>
                    <button id="close-extract-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="p-4 overflow-auto flex-grow">
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">Paste your abstract, paper text, or other content to extract relevant keywords for searching.</p>
                    <textarea 
                        id="extract-text-input" 
                        class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 h-40 text-base"
                        placeholder="Paste your text here..."
                    ></textarea>
                    
                    <div id="extraction-results" class="mt-4 hidden">
                        <h4 class="font-medium mb-2">Extracted Keywords:</h4>
                        <div id="keywords-container" class="flex flex-wrap gap-2 mb-4"></div>
                        <button id="use-all-keywords" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors mr-2">
                            Use All Keywords
                        </button>
                        <button id="use-selected-keywords" class="bg-gray-600 text-white px-4 py-2 rounded-lg hover:bg-gray-700 transition-colors">
                            Use Selected Keywords
                        </button>
                    </div>

                    <div id="extraction-loading" class="text-center py-4 mt-4 hidden">
                        <div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
                        <p class="mt-2 text-gray-600 dark:text-gray-400">Analyzing text and extracting keywords...</p>
                    </div>
                    
                    <div id="extraction-error" class="bg-red-100 dark:bg-red-900 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-200 p-4 rounded-lg mt-4 hidden">
                        <p id="extraction-error-message">An error occurred during keyword extraction.</p>
                    </div>
                </div>
                <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-between">
                    <span class="text-sm text-gray-500 dark:text-gray-400">Powered by Claude</span>
                    <button id="extract-keywords-btn-submit" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" />
                        </svg>
                        Extract Keywords
                    </button>
                </div>
            </div>
        </div>
        
        <!-- PDF Viewer and Analyzer Modal -->
        <div id="pdf-viewer-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col">
                <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h3 class="text-lg font-semibold">PDF Analyzer</h3>
                    <button id="close-pdf-modal" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                
                <!-- PDF Input Section -->
                <div id="pdf-input-section" class="p-4 border-b border-gray-200 dark:border-gray-700">
                    <div class="flex flex-col md:flex-row gap-4 mb-4">
                        <div class="flex-1">
                            <div class="flex mb-4 border border-gray-300 dark:border-gray-600 rounded-md overflow-hidden">
                                <button id="urlTabBtn" class="flex-1 py-2 px-4 font-medium bg-primary text-white">PDF URL</button>
                                <button id="doiTabBtn" class="flex-1 py-2 px-4 font-medium bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300">DOI</button>
                                <button id="arxivTabBtn" class="flex-1 py-2 px-4 font-medium bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300">arXiv ID</button>
                            </div>
                            
                            <div id="urlInputTab">
                                <input type="url" id="pdfUrl" placeholder="Enter direct PDF URL" 
                                    class="w-full px-4 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                            </div>
                            
                            <div id="doiInputTab" class="hidden">
                                <input type="text" id="doiInput" placeholder="Enter DOI (e.g., 10.1038/s41586-020-2012-7)" 
                                    class="w-full px-4 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                            </div>
                            
                            <div id="arxivInputTab" class="hidden">
                                <input type="text" id="arxivInput" placeholder="Enter arXiv ID (e.g., 2210.08282)" 
                                    class="w-full px-4 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                            </div>
                        </div>
                        
                        <div>
                            <button id="fetchPdfBtn" class="h-full bg-primary hover:bg-opacity-90 text-white font-medium py-2 px-4 rounded-md focus:outline-none focus:ring-2 focus:ring-primary focus:ring-opacity-50 transition-colors">
                                Fetch PDF
                            </button>
                        </div>
                    </div>
                    
                    <div id="pdf-info" class="hidden">
                        <div class="flex flex-col md:flex-row justify-between items-start mb-4">
                            <div>
                                <h4 class="font-medium">PDF Information</h4>
                                <p id="pdf-title" class="text-sm text-gray-600 dark:text-gray-400"></p>
                                <p id="pdf-pages" class="text-sm text-gray-600 dark:text-gray-400"></p>
                            </div>
                            <div class="flex-shrink-0 mt-2 md:mt-0">
                                <button id="analyze-pdf-btn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors flex items-center">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                                    </svg>
                                    Analyze with GPT
                                </button>
                            </div>
                        </div>
                        
                        <div class="flex flex-col md:flex-row gap-4 mb-4">
                            <div class="md:w-1/2">
                                <label class="block text-sm font-medium mb-1">Page Range</label>
                                <div class="flex gap-2">
                                    <select id="page-range-type" class="flex-grow px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                                        <option value="all">All Pages</option>
                                        <option value="range">Custom Range</option>
                                    </select>
                                    <div id="page-range-inputs" class="flex items-center gap-2 hidden">
                                        <input type="number" id="start-page" min="1" value="1" class="w-16 px-2 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                                        <span>to</span>
                                        <input type="number" id="end-page" min="1" class="w-16 px-2 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                                    </div>
                                </div>
                            </div>
                            
                            <div class="md:w-1/2">
                                <label for="analysis-type" class="block text-sm font-medium mb-1">Analysis Type</label>
                                <select id="analysis-type" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white">
                                    <option value="paper-improvement">Paper Improvement Suggestions</option>
                                    <option value="summary">Summary & Key Points</option>
                                    <option value="detailed">Detailed Analysis</option>
                                    <option value="references">Extract References</option>
                                    <option value="custom">Custom Analysis</option>
                                </select>
                            </div>
                        </div>
                        
                        <div id="custom-prompt-container" class="hidden">
                            <label for="custom-prompt" class="block text-sm font-medium mb-1">Custom Analysis Instructions</label>
                            <textarea id="custom-prompt" rows="2" placeholder="Enter specific instructions for analysis..."
                                class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white"></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- PDF Loading -->
                <div id="pdf-loading" class="hidden p-8 text-center">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-primary mb-4"></div>
                    <p id="pdf-loading-message" class="text-gray-600 dark:text-gray-400">Fetching PDF...</p>
                </div>
                
                <!-- PDF Analyzing -->
                <div id="pdf-analyzing" class="hidden p-8 text-center">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-primary mb-4"></div>
                    <p class="text-gray-600 dark:text-gray-400">Analyzing PDF with GPT...</p>
                    <p id="analysis-status" class="text-sm text-gray-500 dark:text-gray-400 mt-2"></p>
                </div>
                
                <!-- Analysis Results -->
                <div id="pdf-results-section" class="hidden flex-grow p-4 overflow-auto">
                    <div id="pdf-analysis-result" class="prose dark:prose-invert max-w-none"></div>
                </div>
                
                <!-- Error Message -->
                <div id="pdf-error" class="hidden p-4 mb-4 bg-red-100 dark:bg-red-900 border-l-4 border-red-500 text-red-700 dark:text-red-200">
                    <p id="pdf-error-text"></p>
                </div>
                
                <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <span id="pdf-status" class="text-sm text-gray-500 dark:text-gray-400">Ready to fetch PDF</span>
                    <div class="flex gap-2">
                        <button id="use-for-polish-btn" class="hidden bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 transition-colors">
                            Use for Paper Polishing
                        </button>
                        <button id="export-analysis-btn" class="hidden bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors">
                            Copy Analysis
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Paper Polishing Section (Collapsible) -->
        <div id="paper-polish-section" class="bg-white dark:bg-gray-800 rounded-lg shadow-md mt-8 hidden">
            <div class="p-4 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                <h3 class="text-lg font-semibold">Paper Polishing</h3>
                <button id="close-polish-section" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <div class="p-4">
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">Paste your draft paper below. The system will analyze your content alongside selected references to provide improvement suggestions and create a polished version.</p>
                
                <div class="mb-6">
                    <label for="polish-draft-input" class="block text-sm font-medium mb-2">Draft Paper</label>
                    <textarea 
                        id="polish-draft-input" 
                        class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 h-40 text-base"
                        placeholder="Paste your draft paper here..."
                    ></textarea>
                </div>
                
                <div class="mb-6">
                    <label for="polish-keywords-input" class="block text-sm font-medium mb-2">Additional Keywords (optional)</label>
                    <input 
                        type="text" 
                        id="polish-keywords-input" 
                        class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-primary focus:outline-none border-gray-300 dark:border-gray-600 dark:bg-gray-700 text-base"
                        placeholder="Enter additional keywords separated by commas..."
                    >
                </div>
                
                <div id="polish-references-section" class="mb-6">
                    <h4 class="text-sm font-medium mb-2">Selected References (<span id="polish-ref-count">0</span>)</h4>
                    <div id="polish-no-refs" class="text-yellow-600 dark:text-yellow-400 bg-yellow-100 dark:bg-yellow-900/30 p-3 rounded-lg text-sm">
                        No references selected. Please search and select papers before polishing.
                    </div>
                    <div id="polish-refs-list" class="text-sm max-h-32 overflow-y-auto border rounded-lg p-3 dark:border-gray-600 hidden"></div>
                </div>
                
                <div id="polish-results" class="hidden">
                    <div class="border-t border-gray-200 dark:border-gray-700 pt-6 mb-6">
                        <h4 class="text-lg font-medium mb-4">Improvement Suggestions</h4>
                        <div id="polish-suggestions" class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg text-gray-800 dark:text-gray-200"></div>
                    </div>
                    
                    <div class="border-t border-gray-200 dark:border-gray-700 pt-6">
                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-lg font-medium">Polished Paper (Markdown)</h4>
                            <button id="copy-polished-paper" class="bg-primary text-white px-3 py-1.5 rounded-lg hover:bg-primary/90 transition-colors text-sm flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                                </svg>
                                Copy
                            </button>
                        </div>
                        <div id="polished-paper-container" class="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg overflow-auto max-h-80 text-gray-800 dark:text-gray-200 whitespace-pre-wrap"></div>
                        
                        <div class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                            <p>The citations use the format [^FirstAuthorLastNameYearFirstWordOfTitle] which matches the generated BibTeX citations.</p>
                        </div>
                    </div>
                </div>
                
                <div id="polish-loading" class="text-center py-8 hidden">
                    <div class="inline-block animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-primary mb-4"></div>
                    <p class="text-gray-600 dark:text-gray-400">Analyzing paper and generating improvements...</p>
                    <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">This may take a minute or two depending on the length of your paper.</p>
                </div>
                
                <div id="polish-error" class="bg-red-100 dark:bg-red-900 border border-red-200 dark:border-red-800 text-red-700 dark:text-red-200 p-4 rounded-lg mt-4 hidden">
                    <p id="polish-error-message">An error occurred during paper polishing.</p>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-between">
                <span class="text-sm text-gray-500 dark:text-gray-400">Using selected references and Claude</span>
                <button id="polish-paper-btn-submit" class="bg-primary text-white px-4 py-2 rounded-lg hover:bg-primary/90 transition-colors flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                    </svg>
                    Polish Paper
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // PDF viewer and analysis functionality
            const pdfViewerModal = document.getElementById('pdf-viewer-modal');
            const closePdfModalBtn = document.getElementById('close-pdf-modal');
            const urlTabBtn = document.getElementById('urlTabBtn');
            const doiTabBtn = document.getElementById('doiTabBtn');
            const arxivTabBtn = document.getElementById('arxivTabBtn');
            const urlInputTab = document.getElementById('urlInputTab');
            const doiInputTab = document.getElementById('doiInputTab');
            const arxivInputTab = document.getElementById('arxivInputTab');
            const pdfUrlInput = document.getElementById('pdfUrl');
            const doiInput = document.getElementById('doiInput');
            const arxivInput = document.getElementById('arxivInput');
            const fetchPdfBtn = document.getElementById('fetchPdfBtn');
            const pdfInfo = document.getElementById('pdf-info');
            const pdfTitle = document.getElementById('pdf-title');
            const pdfPages = document.getElementById('pdf-pages');
            const pdfLoading = document.getElementById('pdf-loading');
            const pdfLoadingMessage = document.getElementById('pdf-loading-message');
            const pdfError = document.getElementById('pdf-error');
            const pdfErrorText = document.getElementById('pdf-error-text');
            const pdfStatus = document.getElementById('pdf-status');
            const analyzePdfBtn = document.getElementById('analyze-pdf-btn');
            const pageRangeType = document.getElementById('page-range-type');
            const pageRangeInputs = document.getElementById('page-range-inputs');
            const startPage = document.getElementById('start-page');
            const endPage = document.getElementById('end-page');
            const analysisType = document.getElementById('analysis-type');
            const customPromptContainer = document.getElementById('custom-prompt-container');
            const customPrompt = document.getElementById('custom-prompt');
            const pdfAnalyzing = document.getElementById('pdf-analyzing');
            const analysisStatus = document.getElementById('analysis-status');
            const pdfResultsSection = document.getElementById('pdf-results-section');
            const pdfAnalysisResult = document.getElementById('pdf-analysis-result');
            const useForPolishBtn = document.getElementById('use-for-polish-btn');
            const exportAnalysisBtn = document.getElementById('export-analysis-btn');
            
            // PDF.js variables
            let pdfDocument = null;
            let pdfText = '';
            const CHUNK_SIZE = 8000; // Approximate token limit for GPT-4o-mini
            
            // Handle tab switching in PDF viewer
            urlTabBtn.addEventListener('click', () => switchPdfTab('url'));
            doiTabBtn.addEventListener('click', () => switchPdfTab('doi'));
            arxivTabBtn.addEventListener('click', () => switchPdfTab('arxiv'));
            
            // Listen for analyze button clicks in search results
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('analyze-pdf-btn') || 
                    e.target.parentElement.classList.contains('analyze-pdf-btn')) {
                    
                    const button = e.target.classList.contains('analyze-pdf-btn') ? 
                        e.target : e.target.parentElement;
                    
                    const arxivId = button.dataset.arxivId;
                    const doi = button.dataset.doi;
                    const url = button.dataset.url;
                    const paperTitle = button.dataset.paperTitle;
                    
                    if (arxivId) {
                        openPdfViewer('arxiv', arxivId, paperTitle);
                    } else if (doi) {
                        openPdfViewer('doi', doi, paperTitle);
                    } else if (url) {
                        openPdfViewer('url', url, paperTitle);
                    }
                }
            });
            
            // Open PDF viewer with predefined values
            function openPdfViewer(type, value, title) {
                pdfViewerModal.classList.remove('hidden');
                
                // Reset state
                pdfDocument = null;
                pdfText = '';
                pdfInfo.classList.add('hidden');
                pdfLoading.classList.add('hidden');
                pdfError.classList.add('hidden');
                pdfResultsSection.classList.add('hidden');
                pdfAnalyzing.classList.add('hidden');
                useForPolishBtn.classList.add('hidden');
                exportAnalysisBtn.classList.add('hidden');
                
                // Switch to appropriate tab
                switchPdfTab(type);
                
                // Fill in the value
                if (type === 'url') {
                    pdfUrlInput.value = value;
                } else if (type === 'doi') {
                    doiInput.value = value;
                } else if (type === 'arxiv') {
                    arxivInput.value = value;
                }
                
                // If we have both a value and a title, fetch automatically
                if (value && title) {
                    pdfStatus.textContent = `Preparing to fetch PDF for: ${title}`;
                    setTimeout(() => fetchPdf(), 100);
                }
            }
            
            function switchPdfTab(tabName) {
                // Reset all tabs
                urlTabBtn.classList.remove('bg-primary', 'text-white');
                doiTabBtn.classList.remove('bg-primary', 'text-white');
                arxivTabBtn.classList.remove('bg-primary', 'text-white');
                
                urlTabBtn.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                doiTabBtn.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                arxivTabBtn.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                
                urlInputTab.classList.add('hidden');
                doiInputTab.classList.add('hidden');
                arxivInputTab.classList.add('hidden');
                
                // Activate selected tab
                if (tabName === 'url') {
                    urlTabBtn.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                    urlTabBtn.classList.add('bg-primary', 'text-white');
                    urlInputTab.classList.remove('hidden');
                } else if (tabName === 'doi') {
                    doiTabBtn.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                    doiTabBtn.classList.add('bg-primary', 'text-white');
                    doiInputTab.classList.remove('hidden');
                } else if (tabName === 'arxiv') {
                    arxivTabBtn.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                    arxivTabBtn.classList.add('bg-primary', 'text-white');
                    arxivInputTab.classList.remove('hidden');
                }
            }
            
            // Close PDF modal
            closePdfModalBtn.addEventListener('click', function() {
                pdfViewerModal.classList.add('hidden');
            });
            
            // Close modal when clicking outside the content
            pdfViewerModal.addEventListener('click', function(e) {
                if (e.target === pdfViewerModal) {
                    pdfViewerModal.classList.add('hidden');
                }
            });
            
            // Show/hide page range inputs
            pageRangeType.addEventListener('change', function() {
                if (this.value === 'range') {
                    pageRangeInputs.classList.remove('hidden');
                } else {
                    pageRangeInputs.classList.add('hidden');
                }
            });
            
            // Show/hide custom prompt input
            analysisType.addEventListener('change', function() {
                if (this.value === 'custom') {
                    customPromptContainer.classList.remove('hidden');
                } else {
                    customPromptContainer.classList.add('hidden');
                }
            });
            
            // Fetch PDF function
            fetchPdfBtn.addEventListener('click', fetchPdf);
            
            async function fetchPdf() {
                // Reset state
                pdfDocument = null;
                pdfText = '';
                pdfInfo.classList.add('hidden');
                pdfResultsSection.classList.add('hidden');
                pdfAnalyzing.classList.add('hidden');
                useForPolishBtn.classList.add('hidden');
                exportAnalysisBtn.classList.add('hidden');
                pdfError.classList.add('hidden');
                
                // Show loading state
                pdfLoading.classList.remove('hidden');
                pdfLoadingMessage.textContent = 'Fetching PDF...';
                
                try {
                    // Determine which tab is active and get the URL
                    let pdfUrl = '';
                    
                    if (!urlInputTab.classList.contains('hidden')) {
                        // URL tab is active
                        pdfUrl = pdfUrlInput.value.trim();
                        
                        if (!pdfUrl) {
                            showPdfError('Please enter a valid PDF URL');
                            pdfLoading.classList.add('hidden');
                            return;
                        }
                        
                        // Simple validation - more permissive to allow fragment identifiers
                        if (!pdfUrl.toLowerCase().includes('.pdf') && !pdfUrl.includes('pdf')) {
                            showPdfError('URL does not appear to be a PDF. Please enter a direct PDF URL.');
                            pdfLoading.classList.add('hidden');
                            return;
                        }
                    } else if (!doiInputTab.classList.contains('hidden')) {
                        // DOI tab is active
                        const doi = doiInput.value.trim();
                        
                        if (!doi) {
                            showPdfError('Please enter a valid DOI');
                            pdfLoading.classList.add('hidden');
                            return;
                        }
                        
                        pdfLoadingMessage.textContent = 'Looking up DOI and fetching PDF...';
                        
                        try {
                            // Format the DOI correctly
                            const formattedDoi = doi.replace(/^(https?:\/\/(dx\.)?doi\.org\/)?/, '');
                            
                            // Try to find PDF from SciHub or other sources
                            pdfUrl = await getPdfUrlFromDoi(formattedDoi);
                            
                            if (!pdfUrl) {
                                showPdfError('Could not find a PDF for this DOI. You may need to use a direct PDF URL instead.');
                                pdfLoading.classList.add('hidden');
                                return;
                            }
                        } catch (error) {
                            showPdfError(`Error resolving DOI: ${error.message}`);
                            pdfLoading.classList.add('hidden');
                            return;
                        }
                    } else if (!arxivInputTab.classList.contains('hidden')) {
                        // arXiv tab is active
                        const arxivId = arxivInput.value.trim();
                        
                        if (!arxivId) {
                            showPdfError('Please enter a valid arXiv ID');
                            pdfLoading.classList.add('hidden');
                            return;
                        }
                        
                        // Extract just the ID part
                        let cleanArxivId = arxivId.trim();
                        
                        // Remove 'arXiv:' prefix if present
                        if (cleanArxivId.toLowerCase().startsWith('arxiv:')) {
                            cleanArxivId = cleanArxivId.substring(6);
                        }
                        
                        // Handle URLs in the form arxiv.org/abs/...
                        if (arxivId.includes('arxiv.org')) {
                            const match = arxivId.match(/arxiv\.org\/(?:abs|pdf)\/([^\/\?#]+)/i);
                            if (match) {
                                cleanArxivId = match[1];
                            } else {
                                showPdfError('Could not extract a valid arXiv ID from the entered URL');
                                pdfLoading.classList.add('hidden');
                                return;
                            }
                        }
                        
                        // Construct PDF URL from arXiv ID
                        pdfUrl = cleanArxivId.includes('v') ? 
                            `https://arxiv.org/pdf/${cleanArxivId}` : 
                            `https://arxiv.org/pdf/${cleanArxivId}.pdf`;
                    }
                    
                    console.log(`Fetching PDF from: ${pdfUrl}`);
                    pdfStatus.textContent = `Fetching from: ${pdfUrl}`;
                    
                    // Set up the XHR request
                    const xhr = new XMLHttpRequest();
                    
                    // Handle fragment identifiers (#view=FitH) properly
                    let fetchUrl = pdfUrl;
                    
                    // Extract the fragment if present
                    const fragmentIndex = pdfUrl.indexOf('#');
                    let baseUrl = pdfUrl;
                    let fragment = '';
                    
                    if (fragmentIndex > -1) {
                        baseUrl = pdfUrl.substring(0, fragmentIndex);
                        fragment = pdfUrl.substring(fragmentIndex);
                    }
                    
                    // Check if URL contains sci.bban.top specifically
                    if (pdfUrl.includes('sci.bban.top')) {
                        // Use the api.codetabs.com proxy for sci.bban.top
                        fetchUrl = `https://api.codetabs.com/v1/proxy/?quest=${encodeURIComponent(baseUrl)}${encodeURIComponent(fragment)}`;
                        console.log("Using codetabs proxy for sci.bban.top:", fetchUrl);
                    } 
                    // For other cases that need a proxy
                    else if (pdfUrl.includes('sci-hub') || pdfUrl.includes('doi.org') || (!urlInputTab.classList.contains('hidden') && doiInputTab.classList.contains('hidden'))) {
                        // Use corsproxy.io without encoding the URL
                        fetchUrl = `https://api.codetabs.com/v1/proxy/?quest=?${baseUrl}${fragment}`;
                        console.log("Using codetabs proxy for:", fetchUrl);
                    }
                    
                    xhr.open('GET', fetchUrl, true);
                    xhr.responseType = 'arraybuffer';
                    
                    xhr.onload = async function() {
                        if (xhr.status === 200) {
                            try {
                                // Convert to Uint8Array which PDFjs requires
                                const pdfData = new Uint8Array(xhr.response);
                                
                                // Load the PDF document
                                pdfDocument = await pdfjsLib.getDocument({data: pdfData}).promise;
                                const numPages = pdfDocument.numPages;
                                
                                // Set max page values
                                endPage.value = numPages;
                                endPage.max = numPages;
                                startPage.max = numPages;
                                
                                // Display PDF info
                                const filename = pdfUrl.split('/').pop().split(/[\?#]/)[0] || 'PDF Document';
                                pdfTitle.textContent = `Filename: ${filename}`;
                                pdfPages.textContent = `Pages: ${numPages}`;
                                
                                // Show info and enable analyze button
                                pdfInfo.classList.remove('hidden');
                                pdfLoading.classList.add('hidden');
                                pdfStatus.textContent = `PDF loaded: ${numPages} pages`;
                            } catch (error) {
                                console.error('Error processing PDF:', error);
                                showPdfError(`Failed to process PDF: ${error.message}`);
                                pdfLoading.classList.add('hidden');
                                pdfStatus.textContent = 'Error processing PDF';
                            }
                        } else {
                            showPdfError(`Failed to fetch PDF: ${xhr.statusText} (${xhr.status})`);
                            pdfLoading.classList.add('hidden');
                            pdfStatus.textContent = 'Error loading PDF';
                        }
                    };
                    
                    xhr.onerror = function() {
                        showPdfError('Network error or CORS issue when fetching the PDF.');
                        pdfLoading.classList.add('hidden');
                        pdfStatus.textContent = 'Network error';
                    };
                    
                    xhr.ontimeout = function() {
                        showPdfError('Request timed out. The PDF server might be unavailable.');
                        pdfLoading.classList.add('hidden');
                        pdfStatus.textContent = 'Request timed out';
                    };
                    
                    // Set a timeout
                    xhr.timeout = 30000; // 30 seconds
                    
                    // Send the request
                    xhr.send();
                    
                } catch (error) {
                    console.error('Error in fetchPdf:', error);
                    showPdfError(`Error: ${error.message}`);
                    pdfLoading.classList.add('hidden');
                    pdfStatus.textContent = 'Error';
                }
            }
            
            // Core constants for PDF retrieval
            const DEFAULT_SCI_HUB_DOMAINS = ['sci.bban.top', 'sci-hub.st', 'sci-hub.se', 'sci-hub.ee', 'sci-hub.ru'];
            const CORS_PROXY = 'https://corsproxy.io/?';
            const VALID_DOI_REGEX = /^10\.\d{4,9}\/[-._;()/:A-Z0-9]+$/i;
            
            /**
             * Helper function to get PDF URL from DOI
             * @param {string} doi - The DOI to fetch
             * @param {Object} options - Optional configuration
             * @returns {Promise<string>} - The PDF URL
             */
            async function getPdfUrlFromDoi(doi, options = {}) {
                // Clean and validate DOI
                const cleanDoi = doi.replace(/^(https?:\/\/(dx\.)?doi\.org\/)?/, '');
                
                try {
                    if (!cleanDoi) {
                        throw new Error('Empty DOI provided');
                    }
                    
                    // Configuration options with defaults
                    const {
                        sciHubDomains = DEFAULT_SCI_HUB_DOMAINS,
                        timeout = 15000,
                        maxRetries = 1
                    } = options;
                    
                    // Try to get PDF from Sci-Hub first
                    for (const domain of sciHubDomains) {
                        try {
                            console.log(`Trying Sci-Hub domain: ${domain}`);
                            const pdfUrl = await fetchFromSciHub(cleanDoi, domain, timeout);
                            if (pdfUrl) {
                                console.log(`Found PDF URL from ${domain}:`, pdfUrl);
                                return pdfUrl;
                            }
                        } catch (error) {
                            console.error(`Error with ${domain}:`, error.message);
                            // Continue to next domain if this one fails
                        }
                    }
                    
                    // Try Unpaywall as fallback
                    try {
                        console.log('Trying Unpaywall as fallback...');
                        const unpaywallUrl = await fetchFromUnpaywall(cleanDoi, timeout);
                        if (unpaywallUrl) {
                            console.log('Found PDF URL from Unpaywall:', unpaywallUrl);
                            return unpaywallUrl;
                        }
                    } catch (error) {
                        console.error('Error querying Unpaywall:', error.message);
                    }
                    
                    // If all else fails, return the DOI URL through Sci-Hub
                    const fallbackUrl = `https://${sciHubDomains[0]}/doi/${cleanDoi}`;
                    console.log(`No direct PDF found. Returning fallback URL: ${fallbackUrl}`);
                    return fallbackUrl;
                    
                } catch (error) {
                    console.error('Error in primary DOI resolution flow:', error);
                    return `https://${DEFAULT_SCI_HUB_DOMAINS[0]}/doi/${cleanDoi}`;
                }
            }
            
            /**
             * Fetches PDF URL from Sci-Hub
             * @param {string} doi - The DOI to fetch
             * @param {string} domain - Sci-Hub domain to use
             * @param {number} timeout - Request timeout in ms
             * @returns {Promise<string|null>} - The PDF URL or null if not found
             */
            function fetchFromSciHub(doi, domain, timeout) {
                return new Promise((resolve, reject) => {
                    const sciHubUrl = `https://${domain}/doi/${doi}`;
                    // Use direct URL for sci.bban.top domain, proxy for others
                    const proxiedUrl = domain === 'sci.bban.top' ? sciHubUrl : `${CORS_PROXY}${sciHubUrl}`;
                    
                    console.log(`Fetching from Sci-Hub: ${proxiedUrl}`);
                    
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', proxiedUrl, true);
                    xhr.responseType = 'text';
                    xhr.timeout = timeout;
                    
                    xhr.onload = function() {
                        if (xhr.status === 200) {
                            try {
                                const htmlContent = xhr.responseText;
                                
                                // 1. Look for iframe with PDF source
                                const iframeSrcMatch = htmlContent.match(/iframe[^>]*src=["']([^"']+)["']/i);
                                if (iframeSrcMatch && iframeSrcMatch[1]) {
                                    resolve(normalizeUrl(iframeSrcMatch[1], domain));
                                    return;
                                }
                                
                                // 2. Look for embed tag
                                const embedSrcMatch = htmlContent.match(/embed[^>]*src=["']([^"']+)["']/i);
                                if (embedSrcMatch && embedSrcMatch[1]) {
                                    resolve(normalizeUrl(embedSrcMatch[1], domain));
                                    return;
                                }
                                
                                // 3. Look for download links explicitly for PDFs
                                const pdfLinkMatch = htmlContent.match(/href=["']([^"']+\.pdf)["']/i);
                                if (pdfLinkMatch && pdfLinkMatch[1]) {
                                    resolve(normalizeUrl(pdfLinkMatch[1], domain));
                                    return;
                                }
                                
                                // 4. Look for citation_pdf_url meta tag
                                const metaPdfMatch = htmlContent.match(/<meta[^>]*name=["']citation_pdf_url["'][^>]*content=["']([^"']+)["']/i);
                                if (metaPdfMatch && metaPdfMatch[1]) {
                                    resolve(normalizeUrl(metaPdfMatch[1], domain));
                                    return;
                                }
                                
                                // 5. Direct PDF detection in URLs
                                const pdfUrlPattern = /["'](https?:\/\/[^"']+\.pdf)["']/i;
                                const directPdfMatch = htmlContent.match(pdfUrlPattern);
                                if (directPdfMatch && directPdfMatch[1]) {
                                    resolve(directPdfMatch[1]);
                                    return;
                                }
                                
                                // Check for captcha or "not found" messages
                                if (htmlContent.includes('captcha') || htmlContent.includes('Captcha')) {
                                    console.log(`${domain} returned a captcha page`);
                                    resolve(null);
                                    return;
                                }
                                
                                if (htmlContent.includes('article not found') || 
                                    htmlContent.includes('Article not found') || 
                                    htmlContent.includes('not found in the database')) {
                                    console.log(`Paper not found in ${domain}`);
                                    resolve(null);
                                    return;
                                }
                                
                                // No PDF URL found
                                console.log(`No PDF URL found in ${domain} response`);
                                resolve(null);
                            } catch (error) {
                                console.error('Error parsing Sci-Hub response:', error);
                                reject(error);
                            }
                        } else {
                            reject(new Error(`HTTP error: ${xhr.status}`));
                        }
                    };
                    
                    xhr.onerror = function() {
                        reject(new Error('Network error'));
                    };
                    
                    xhr.ontimeout = function() {
                        reject(new Error('Request timed out'));
                    };
                    
                    xhr.send();
                });
            }
            
            /**
             * Fetches PDF URL from Unpaywall API
             * @param {string} doi - The DOI to fetch
             * @param {number} timeout - Request timeout in ms
             * @returns {Promise<string|null>} - The PDF URL or null if not found
             */
            function fetchFromUnpaywall(doi, timeout) {
                return new Promise((resolve, reject) => {
                    const email = 'poe@example.com'; // Replace with a valid email
                    const unpaywallUrl = `https://api.unpaywall.org/v2/${doi}?email=${email}`;
                    // CRITICAL: No URL encoding for corsproxy.io
                    const proxiedUrl = `${CORS_PROXY}${unpaywallUrl}`;
                    
                    console.log(`Fetching from Unpaywall: ${proxiedUrl}`);
                    
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', proxiedUrl, true);
                    xhr.responseType = 'json';
                    xhr.timeout = timeout;
                    
                    xhr.onload = function() {
                        if (xhr.status === 200 && xhr.response) {
                            const data = xhr.response;
                            
                            // Check if there's a direct PDF link
                            if (data.best_oa_location && data.best_oa_location.url_for_pdf) {
                                resolve(data.best_oa_location.url_for_pdf);
                            } else if (data.best_oa_location && data.best_oa_location.url) {
                                resolve(data.best_oa_location.url);
                            } else {
                                console.log('No open access PDF found in Unpaywall');
                                resolve(null);
                            }
                        } else {
                            reject(new Error(`Unpaywall API error: ${xhr.status}`));
                        }
                    };
                    
                    xhr.onerror = function() {
                        reject(new Error('Network error'));
                    };
                    
                    xhr.ontimeout = function() {
                        reject(new Error('Request timed out'));
                    };
                    
                    xhr.send();
                });
            }
            
            /**
             * Normalize URL to absolute path
             * @param {string} url - The URL to normalize
             * @param {string} domain - The domain to use for relative URLs
             * @returns {string} - The normalized URL
             */
            function normalizeUrl(url, domain) {
                if (url.startsWith('//')) {
                    return `https:${url}`;
                } else if (url.startsWith('/')) {
                    return `https://${domain}${url}`;
                } else if (!url.startsWith('http')) {
                    return `https://${domain}/${url}`;
                }
                return url;
            }
            
            // Helper function to show PDF error
            function showPdfError(message) {
                pdfErrorText.textContent = message;
                pdfError.classList.remove('hidden');
                pdfStatus.textContent = 'Error';
            }
            
            // Analyze PDF functionality
            analyzePdfBtn.addEventListener('click', analyzePdf);
            
            // Store analysis suggestions for the Polish Paper feature
            let savedAnalysisSuggestions = [];
            
            async function analyzePdf() {
                if (!pdfDocument) {
                    showPdfError('No PDF document loaded');
                    return;
                }
                
                // Get page range
                let startPageNum = 1;
                let endPageNum = pdfDocument.numPages;
                
                if (pageRangeType.value === 'range') {
                    startPageNum = parseInt(startPage.value) || 1;
                    endPageNum = parseInt(endPage.value) || pdfDocument.numPages;
                    
                    // Validate range
                    if (startPageNum < 1) startPageNum = 1;
                    if (endPageNum > pdfDocument.numPages) endPageNum = pdfDocument.numPages;
                    if (startPageNum > endPageNum) {
                        [startPageNum, endPageNum] = [endPageNum, startPageNum]; // Swap if out of order
                    }
                }
                
                // Reset states
                pdfResultsSection.classList.add('hidden');
                pdfAnalysisResult.innerHTML = '';
                useForPolishBtn.classList.add('hidden');
                exportAnalysisBtn.classList.add('hidden');
                
                // Show analyzing state
                pdfAnalyzing.classList.remove('hidden');
                analysisStatus.textContent = 'Preparing to extract text...';
                
                try {
                    // Extract text from PDF
                    pdfText = await extractTextFromPdf(startPageNum, endPageNum);
                    
                    if (!pdfText.trim()) {
                        showPdfError('No text content found in the selected pages. This PDF might be image-based or protected.');
                        pdfAnalyzing.classList.add('hidden');
                        return;
                    }
                    
                    // Check if user has draft paper in Polish section
                    const userDraftPaper = polishDraftInput.value.trim();
                    const hasDraftPaper = userDraftPaper.length > 0;
                    
                    // Add user draft info section
                    let userDraftSection = '';
                    if (hasDraftPaper && analysisType.value === 'paper-improvement') {
                        // Add checkbox to let users toggle if they want to use their draft
                        const draftExistsDiv = document.createElement('div');
                        draftExistsDiv.className = 'mb-3 p-3 bg-blue-50 dark:bg-blue-900/20 rounded';
                        draftExistsDiv.innerHTML = `
                            <div class="flex items-center">
                                <input type="checkbox" id="include-draft-checkbox" class="h-4 w-4 text-primary border-gray-300 rounded focus:ring-primary mr-2" checked>
                                <label for="include-draft-checkbox" class="text-sm">Include your draft paper in the analysis (recommended for more targeted suggestions)</label>
                            </div>
                            <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Found ${userDraftPaper.length} characters in your draft</p>
                        `;
                        
                        // Remove any existing draft info element
                        const existingDraftInfo = document.getElementById('draft-exists-info');
                        if (existingDraftInfo) {
                            existingDraftInfo.remove();
                        }
                        
                        // Add the info to the PDF info section
                        draftExistsDiv.id = 'draft-exists-info';
                        pdfInfo.appendChild(draftExistsDiv);
                        
                        userDraftSection = `\n\n==== USER'S DRAFT PAPER ====\n${userDraftPaper}`;
                    }
                    
                    // Prepare chunks for analysis if the text is long
                    const chunks = prepareTextChunks(pdfText);
                    
                    // Set up handler ID for this analysis
                    const handlerId = `pdf-analysis-${Date.now()}`;
                    
                    // Register handler for streaming response
                    window.Poe.registerHandler(handlerId, (result) => {
                        if (result.status === "error") {
                            pdfAnalyzing.classList.add('hidden');
                            showPdfError(`Analysis error: ${result.statusText || 'Unknown error'}`);
                            return;
                        }
                        
                        if (result.responses && result.responses.length > 0) {
                            const response = result.responses[0];
                            
                            if (response.status === "incomplete") {
                                // Update with partial content while streaming
                                pdfAnalysisResult.innerHTML = marked.parse(response.content);
                                pdfResultsSection.classList.remove('hidden');
                            } else if (response.status === "complete") {
                                // Show complete results
                                pdfAnalysisResult.innerHTML = marked.parse(response.content);
                                pdfResultsSection.classList.remove('hidden');
                                pdfAnalyzing.classList.add('hidden');
                                
                                // Show action buttons
                                useForPolishBtn.classList.remove('hidden');
                                exportAnalysisBtn.classList.remove('hidden');
                                
                                pdfStatus.textContent = 'Analysis complete';
                                
                                // Store the analysis suggestions for the Polish Paper feature
                                // Save the full content if it's paper improvement analysis
                                if (analysisType.value === 'paper-improvement') {
                                    let sourceInfo = pdfTitle.textContent.replace('Filename: ', '');
                                    if (hasDraftPaper && document.getElementById('include-draft-checkbox')?.checked) {
                                        sourceInfo += ' (compared with your draft)';
                                    }
                                    
                                    savedAnalysisSuggestions.push({
                                        timestamp: new Date().toISOString(),
                                        content: response.content,
                                        source: sourceInfo
                                    });
                                    
                                    // Update the polish section suggestions if it's open
                                    if (!paperPolishSection.classList.contains('hidden')) {
                                        updatePolishSectionWithSuggestions();
                                    }
                                }
                            }
                        }
                    });
                    
                    // Build the prompt based on analysis type
                    let promptPrefix = '';
                    
                    if (analysisType.value === 'paper-improvement') {
                        // Check if we should include the user's draft
                        const includeDraft = hasDraftPaper && document.getElementById('include-draft-checkbox')?.checked;
                        
                        if (includeDraft) {
                            promptPrefix = `I am going to provide:
1. The text content from a research paper PDF
2. The user's own draft paper

Please analyze both documents and provide detailed suggestions for how the user can improve their draft by leveraging concepts, methods, insights, or approaches from the PDF document. Focus on:

1. Key insights, methodologies, or findings from the PDF that could strengthen the user's paper
2. Specific sections of the user's draft that could be enhanced using information from the PDF
3. Useful citations or references from the PDF that the user should integrate
4. Conceptual frameworks or theoretical approaches from the PDF that might complement the user's work
5. Potential counterarguments or limitations addressed in the PDF that the user should consider
6. Stylistic or structural elements from the PDF that the user could emulate

Organize your response in clear sections with concrete, specific suggestions that explain both WHAT from the PDF could be useful and HOW the user should incorporate it into their work.`;
                        } else {
                            promptPrefix = `Please analyze the following academic paper PDF content and provide detailed suggestions for ways this content could be used to improve, enhance, or complement a user's own academic paper. Focus on:

1. Key insights, methodologies, or findings that could strengthen the user's paper
2. Useful citations or references that could be integrated
3. Conceptual frameworks or theoretical approaches that might be valuable
4. Potential counterarguments or limitations to consider
5. Stylistic or structural elements worth emulating

Organize your response in clear sections with concrete, specific suggestions that explain both WHAT could be useful from this paper and HOW the user might incorporate it into their own work.`;
                        }
                    } else if (analysisType.value === 'summary') {
                        promptPrefix = `Please analyze the following PDF document content and provide a detailed summary, highlighting the main points, methodology, findings, and conclusions.`;
                    } else if (analysisType.value === 'detailed') {
                        promptPrefix = `Please provide a comprehensive analysis of the following PDF document, including the research question, theoretical framework, methodology, key findings, limitations, and implications.`;
                    } else if (analysisType.value === 'references') {
                        promptPrefix = `Please extract and format all references from the following PDF document. For each reference, provide the full citation in a consistent academic format.`;
                    } else if (analysisType.value === 'custom') {
                        promptPrefix = customPrompt.value.trim() || 'Please analyze the following PDF document.';
                    }
                    
                    // Create context about document size
                    const pageInfo = startPageNum === endPageNum 
                        ? `Page ${startPageNum}` 
                        : `Pages ${startPageNum} to ${endPageNum}`;
                    
                    const contextInfo = chunks.length === 1
                        ? `Here is the full text content from the PDF document (${pageInfo}):`
                        : `The following is the text content from a PDF document (${pageInfo}). The content is quite long, so I'm providing what could be extracted:`;
                    
                    // Send to Claude for analysis
                    analysisStatus.textContent = 'Sending to Claude for analysis...';
                    
                    // Check if we should include user's draft in the analysis
                    const includeDraft = hasDraftPaper && 
                                        analysisType.value === 'paper-improvement' && 
                                        document.getElementById('include-draft-checkbox')?.checked;
                    
                    // Use Claude-3.7-Sonnet for longer context window
                    // Prepare the PDF content - try to use as much as possible while staying within limits
                    const MAX_CLAUDE_TOKENS = 180000; // 字符数的近似值，实际token数会根据文本内容有所不同
                    let pdfContent = '';
                    let truncated = false;
                    
                    // 计算大致的预估字符数
                    const userDraftLength = includeDraft ? userDraftSection.length : 0;
                    const contextInfoLength = contextInfo.length;
                    const promptPrefixLength = promptPrefix.length;
                    const overheadLength = 500; // 额外预留空间
                    
                    // 计算可用于PDF文本的字符数
                    const availableForPdf = MAX_CLAUDE_TOKENS - userDraftLength - contextInfoLength - promptPrefixLength - overheadLength;
                    
                    // 尽可能多地包含PDF内容
                    if (pdfText.length <= availableForPdf) {
                        // 整个PDF可以被包含
                        pdfContent = pdfText;
                    } else {
                        // 需要截断PDF文本
                        pdfContent = pdfText.substring(0, availableForPdf);
                        truncated = true;
                    }
                    
                    // 如果被截断，添加说明
                    if (truncated) {
                        pdfContent += "\n\n[Content truncated due to length limitations]";
                    }
                    
                    // 构建最终内容
                    const finalContent = includeDraft 
                        ? `${contextInfo}\n\n${pdfContent}${userDraftSection}` 
                        : `${contextInfo}\n\n${pdfContent}`;
                    
                    const prompt = `@Claude-3.7-Sonnet ${promptPrefix}\n\n${finalContent}`;
                    
                    await window.Poe.sendUserMessage(prompt, {
                        handler: handlerId,
                        stream: true,
                        openChat: false
                    });
                    
                } catch (error) {
                    console.error('Error analyzing PDF:', error);
                    pdfAnalyzing.classList.add('hidden');
                    showPdfError(`Error during analysis: ${error.message}`);
                }
            }
            
            // Update the polish section with saved suggestions
            function updatePolishSectionWithSuggestions() {
                if (savedAnalysisSuggestions.length === 0) return;
                
                // Create a div to contain the suggestions
                const suggestionsDiv = document.createElement('div');
                suggestionsDiv.className = 'mb-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg';
                
                // Add a header
                const header = document.createElement('h3');
                header.className = 'text-lg font-medium mb-2';
                header.textContent = 'Previously Generated Suggestions:';
                suggestionsDiv.appendChild(header);
                
                // Add each suggestion
                savedAnalysisSuggestions.forEach((suggestion, index) => {
                    const suggestionContainer = document.createElement('div');
                    suggestionContainer.className = 'mb-3 pb-3 border-b border-blue-200 dark:border-blue-800 last:border-0';
                    
                    // Format the date
                    const date = new Date(suggestion.timestamp);
                    const formattedDate = date.toLocaleString();
                    
                    // Add source and date
                    const sourceInfo = document.createElement('p');
                    sourceInfo.className = 'text-sm text-gray-600 dark:text-gray-400 mb-2';
                    sourceInfo.textContent = `From ${suggestion.source} analyzed on ${formattedDate}`;
                    suggestionContainer.appendChild(sourceInfo);
                    
                    // Add content
                    const content = document.createElement('div');
                    content.className = 'text-sm';
                    content.innerHTML = marked.parse(suggestion.content);
                    suggestionContainer.appendChild(content);
                    
                    // Add a "Use This" button
                    const useButton = document.createElement('button');
                    useButton.className = 'mt-2 px-3 py-1 bg-primary text-white text-xs rounded hover:bg-primary/90';
                    useButton.textContent = 'Use These Suggestions';
                    useButton.addEventListener('click', () => {
                        // Set this content as the polish input
                        polishSuggestions.innerHTML = marked.parse(suggestion.content);
                        polishResults.classList.remove('hidden');
                    });
                    suggestionContainer.appendChild(useButton);
                    
                    suggestionsDiv.appendChild(suggestionContainer);
                });
                
                // Check if suggestions element already exists and replace it
                const existingSuggestions = document.getElementById('savedSuggestions');
                if (existingSuggestions) {
                    existingSuggestions.replaceWith(suggestionsDiv);
                } else {
                    // Find where to insert the suggestions
                    const polishSectionContent = document.querySelector('#paper-polish-section > div');
                    if (polishSectionContent && polishSectionContent.children.length > 0) {
                        // Insert after the first paragraph
                        const firstParagraph = polishSectionContent.children[0];
                        suggestionsDiv.id = 'savedSuggestions';
                        firstParagraph.after(suggestionsDiv);
                    }
                }
            }
            
            // Extract text from PDF pages
            async function extractTextFromPdf(startPage, endPage) {
                let extractedText = '';
                
                try {
                    for (let i = startPage; i <= endPage; i++) {
                        const page = await pdfDocument.getPage(i);
                        const textContent = await page.getTextContent();
                        
                        // Join all text items with spaces
                        const pageText = textContent.items
                            .map(item => item.str)
                            .join(' ');
                        
                        extractedText += pageText + '\n\n';
                        
                        // Update status
                        analysisStatus.textContent = `Extracting text from page ${i} of ${endPage}...`;
                        
                        // Release page resources
                        page.cleanup();
                    }
                } catch (error) {
                    console.error('Error extracting text:', error);
                    throw new Error(`Failed to extract text from PDF: ${error.message}`);
                }
                
                return extractedText;
            }
            
            // Prepare text chunks for analysis
            function prepareTextChunks(text) {
                const chunks = [];
                
                // If text is short enough, return as a single chunk
                if (text.length <= CHUNK_SIZE) {
                    return [text];
                }
                
                // Otherwise, split by sections or paragraphs
                for (let i = 0; i < text.length; i += CHUNK_SIZE) {
                    chunks.push(text.substring(i, i + CHUNK_SIZE));
                }
                
                return chunks;
            }
            
            // Copy analysis to clipboard
            exportAnalysisBtn.addEventListener('click', function() {
                const analysisText = pdfAnalysisResult.textContent;
                
                try {
                    navigator.clipboard.writeText(analysisText).then(() => {
                        // Show success feedback
                        const originalText = this.textContent;
                        this.textContent = 'Copied!';
                        
                        setTimeout(() => {
                            this.textContent = originalText;
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        alert('Failed to copy. Please try selecting and copying manually.');
                    });
                } catch (err) {
                    console.error('Clipboard API not available:', err);
                    alert('Failed to copy. Please try selecting and copying manually.');
                }
            });
            
            // Use analysis for paper polishing
            useForPolishBtn.addEventListener('click', function() {
                // Get the analysis text
                const analysisText = pdfAnalysisResult.textContent;
                
                // Check if we have content to add
                if (!analysisText.trim()) {
                    alert('No analysis content to add to paper polishing.');
                    return;
                }
                
                // Open the paper polishing section
                paperPolishSection.classList.remove('hidden');
                
                // Add the analysis to the draft
                let currentDraft = polishDraftInput.value.trim();
                
                if (currentDraft) {
                    // Append to existing text
                    polishDraftInput.value = currentDraft + '\n\n# Analysis from PDF\n\n' + analysisText;
                } else {
                    // Set as new text
                    polishDraftInput.value = analysisText;
                }
                
                // Close the PDF viewer
                pdfViewerModal.classList.add('hidden');
                
                // Scroll to the polishing section
                paperPolishSection.scrollIntoView({ behavior: 'smooth' });
            });
            // Paper Polishing functionality
            const polishPaperButton = document.getElementById('polish-paper-button');
            const paperPolishSection = document.getElementById('paper-polish-section');
            const closePolishSectionBtn = document.getElementById('close-polish-section');
            const polishDraftInput = document.getElementById('polish-draft-input');
            const polishKeywordsInput = document.getElementById('polish-keywords-input');
            const polishRefsSection = document.getElementById('polish-references-section');
            const polishRefCount = document.getElementById('polish-ref-count');
            const polishNoRefs = document.getElementById('polish-no-refs');
            const polishRefsList = document.getElementById('polish-refs-list');
            const polishResults = document.getElementById('polish-results');
            const polishSuggestions = document.getElementById('polish-suggestions');
            const polishedPaperContainer = document.getElementById('polished-paper-container');
            const polishLoading = document.getElementById('polish-loading');
            const polishError = document.getElementById('polish-error');
            const polishErrorMessage = document.getElementById('polish-error-message');
            const polishPaperBtnSubmit = document.getElementById('polish-paper-btn-submit');
            const copyPolishedPaperBtn = document.getElementById('copy-polished-paper');
            
            // Show/hide the paper polishing section
            polishPaperButton.addEventListener('click', function() {
                // Toggle visibility - if hidden, show it; if shown, hide it
                if (paperPolishSection.classList.contains('hidden')) {
                    paperPolishSection.classList.remove('hidden');
                    
                    // Reset the section state
                    polishResults.classList.add('hidden');
                    polishLoading.classList.add('hidden');
                    polishError.classList.add('hidden');
                    
                    // If there's text in the Extract Keywords textarea, use it for the Draft Paper
                    const extractText = extractTextInput.value.trim();
                    if (extractText && !polishDraftInput.value.trim()) {
                        polishDraftInput.value = extractText;
                    }
                    
                    polishDraftInput.focus();
                    
                    // Update references list
                    updatePolishReferencesList();
                    
                    // Scroll to the section to ensure it's visible
                    paperPolishSection.scrollIntoView({ behavior: 'smooth' });
                } else {
                    paperPolishSection.classList.add('hidden');
                }
            });
            
            // Close the section
            closePolishSectionBtn.addEventListener('click', function() {
                paperPolishSection.classList.add('hidden');
            });
            
            // Update the references list in the polish modal
            function updatePolishReferencesList() {
                const mergedRefs = Array.from(mergedReferences.values());
                polishRefCount.textContent = mergedRefs.length;
                
                if (mergedRefs.length === 0) {
                    polishNoRefs.classList.remove('hidden');
                    polishRefsList.classList.add('hidden');
                    return;
                }
                
                polishNoRefs.classList.add('hidden');
                polishRefsList.classList.remove('hidden');
                
                // Create list of references
                polishRefsList.innerHTML = '';
                mergedRefs.forEach(paper => {
                    const refItem = document.createElement('div');
                    refItem.className = 'mb-2 pb-2 border-b dark:border-gray-700 last:border-0';
                    
                    // Format the reference info differently based on source
                    let paperInfo = '';
                    if (paper.source === 'arXiv') {
                        const year = paper.published ? paper.published.split(' ')[2] : '';
                        paperInfo = `${paper.authors[0]} et al. (${year}) - ${paper.title}`;
                    } else if (paper.source === 'PubMed') {
                        paperInfo = `${paper.authors[0]} et al. - ${paper.title} (PMID: ${paper.id})`;
                    } else if (paper.source === 'Semantic Scholar') {
                        paperInfo = `${paper.authors[0]} et al. (${paper.year}) - ${paper.title}`;
                    }
                    
                    refItem.textContent = paperInfo;
                    polishRefsList.appendChild(refItem);
                });
            }
            
            // Get citation key for a paper
            function getCitationKey(paper) {
                let year;
                let firstAuthor;
                let title;
                
                // Extract year based on source
                if (paper.source === 'arXiv') {
                    year = paper.published ? paper.published.split(' ')[2] : new Date().getFullYear();
                } else if (paper.source === 'PubMed') {
                    // Try to extract year using regex to find 4-digit number
                    if (paper.published) {
                        const yearMatch = paper.published.match(/\b(\d{4})\b/);
                        year = yearMatch && yearMatch[1] ? yearMatch[1] : new Date().getFullYear();
                    } else {
                        year = new Date().getFullYear();
                    }
                } else if (paper.source === 'Semantic Scholar') {
                    year = paper.year || new Date().getFullYear();
                }
                
                // Extract first author's last name
                firstAuthor = paper.authors && paper.authors.length > 0 ? 
                    paper.authors[0].split(' ').pop() : 'Unknown';
                
                // Get first word of title
                title = paper.title || 'Untitled';
                const firstTitleWord = title.split(/\s+/)[0].replace(/[^a-zA-Z0-9]/g, '');
                
                return `${firstAuthor}${year}${firstTitleWord}`;
            }
            
            // Handle paper polishing submission
            polishPaperBtnSubmit.addEventListener('click', async function() {
                const draftText = polishDraftInput.value.trim();
                if (!draftText) {
                    showPolishError('Please enter your draft paper content.');
                    return;
                }
                
                const mergedRefs = Array.from(mergedReferences.values());
                if (mergedRefs.length === 0) {
                    showPolishError('Please add at least one paper to the merged references before polishing.');
                    return;
                }
                
                // Show loading state
                polishResults.classList.add('hidden');
                polishLoading.classList.remove('hidden');
                polishError.classList.add('hidden');
                
                try {
                    // Prepare BibTeX references
                    let bibtexRefs = '';
                    let citationKeys = [];
                    
                    mergedRefs.forEach(paper => {
                        let bibtex = '';
                        if (paper.source === 'arXiv') {
                            bibtex = generateArXivBibTeX(paper);
                        } else if (paper.source === 'PubMed') {
                            bibtex = generatePubMedBibTeX(paper);
                        } else if (paper.source === 'Semantic Scholar') {
                            bibtex = generateSemanticScholarBibTeX(paper);
                        }
                        
                        bibtexRefs += bibtex + '\n\n';
                        
                        // Extract citation key
                        const citationKey = getCitationKey(paper);
                        citationKeys.push({
                            key: citationKey,
                            title: paper.title,
                            authors: paper.authors.join(', '),
                            source: paper.source,
                            id: paper.id || paper.paperId
                        });
                    });
                    
                    // Get additional keywords if provided
                    const additionalKeywords = polishKeywordsInput.value.trim();
                    
                    // Send the draft and references to Claude for polishing
                    const prompt = `@Claude-3.7-Sonnet I need your help to polish an academic paper draft based on the provided references. I'll provide you with:

1. The draft paper
2. Additional keywords (if any)
3. BibTeX formatted references
4. Citations information with citation keys

First, analyze the provided BibTeX references and the draft paper. Then provide:

1. A detailed list of improvement suggestions based on the referenced literature
2. A polished version of the paper in Markdown format

For the polished paper, integrate insights from the provided references where appropriate. Use the citation format [^CitationKey] which matches the BibTeX citation keys.

The citation keys follow the format FirstAuthorLastNameYearFirstWordOfTitle (e.g., Smith2023Analysis).

Important: Be factual and avoid fabricating data or citations. Only reference content that actually appears in the provided references. If the draft makes claims that aren't supported by the references, suggest in your improvement notes that the author should add supporting evidence.

In the references section of the polished paper, include all available bibliographic details for each citation, including:
- Journal name
- Volume number
- Issue number
- Page numbers
- DOI (if available)

Format the references section in a complete academic style with all these details when available.

==== DRAFT PAPER ====
${draftText}

==== ADDITIONAL KEYWORDS ====
${additionalKeywords}

==== BIBTEX REFERENCES ====
${bibtexRefs}

==== CITATION INFORMATION ====
${JSON.stringify(citationKeys, null, 2)}

Please provide your response in the following format:

## Improvement Suggestions
[List detailed suggestions for improving the paper based on the literature]

## Polished Paper
[Provide the polished paper in Markdown format with proper citations using [^CitationKey] format]
`;
                    
                    // Register a handler for the response
                    window.Poe.registerHandler("paper-polisher", (result, context) => {
                        if (result.status === "error") {
                            showPolishError("Error from Claude: " + (result.statusText || "Unknown error"));
                            polishLoading.classList.add('hidden');
                            return;
                        }
                        
                        if (result.responses && result.responses.length > 0) {
                            const response = result.responses[0];
                            
                            if (response.status === "complete") {
                                try {
                                    const content = response.content;
                                    
                                    // Split the response into suggestions and polished paper
                                    const suggestionsSectionMatch = content.match(/## Improvement Suggestions\s+([\s\S]*?)(?=\s*##\s+Polished Paper|$)/i);
                                    const polishedPaperMatch = content.match(/## Polished Paper\s+([\s\S]*?)(?=$)/i);
                                    
                                    if (suggestionsSectionMatch && polishedPaperMatch) {
                                        const suggestions = suggestionsSectionMatch[1].trim();
                                        const polishedPaper = polishedPaperMatch[1].trim();
                                        
                                        // Convert the markdown to HTML for suggestions
                                        polishSuggestions.innerHTML = convertMarkdownToHTML(suggestions);
                                        
                                        // Leave polished paper as markdown for the text display
                                        polishedPaperContainer.textContent = polishedPaper;
                                        
                                        // Show results
                                        polishResults.classList.remove('hidden');
                                    } else {
                                        showPolishError("Could not parse Claude's response correctly. Please try again.");
                                    }
                                } catch (parseError) {
                                    console.error("Error processing Claude's response:", parseError);
                                    showPolishError("Error processing the polishing results. Please try again.");
                                }
                                
                                polishLoading.classList.add('hidden');
                            }
                        }
                    });
                    
                    // Send the prompt to Claude
                    await window.Poe.sendUserMessage(prompt, {
                        handler: "paper-polisher",
                        stream: false,
                        openChat: false
                    });
                    
                } catch (error) {
                    console.error('Error during paper polishing:', error);
                    showPolishError('Error connecting to Claude: ' + error.message);
                    polishLoading.classList.add('hidden');
                }
            });
            
            // Simple Markdown to HTML conversion
            function convertMarkdownToHTML(markdown) {
                // Handle headers
                let html = markdown
                    .replace(/### (.*?)\n/g, '<h3 class="text-lg font-medium mt-3 mb-2">$1</h3>')
                    .replace(/## (.*?)\n/g, '<h2 class="text-xl font-medium mt-4 mb-2">$1</h2>')
                    .replace(/# (.*?)\n/g, '<h1 class="text-2xl font-bold mt-4 mb-3">$1</h1>');
                
                // Handle lists
                html = html
                    .replace(/^\s*\d+\.\s+(.*?)$/gm, '<li>$1</li>')
                    .replace(/^\s*\*\s+(.*?)$/gm, '<li>$1</li>')
                    .replace(/^\s*-\s+(.*?)$/gm, '<li>$1</li>');
                
                // Wrap adjacent list items in ul/ol tags
                html = html
                    .replace(/(<li>.*?<\/li>)\n(<li>)/g, '$1$2')
                    .replace(/(^|<\/h[1-6]>|<\/p>)\n+(<li>)/g, '$1\n<ul class="list-disc pl-5 mb-3">$2')
                    .replace(/(<\/li>)(?!\n*<li>)/g, '$1</ul>');
                
                // Handle paragraphs
                html = html.replace(/^([^<\n].*?)(?:\n\n|\n*$)/gm, '<p class="mb-3">$1</p>');
                
                // Handle bold, italic, and code
                html = html
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">$1</code>');
                
                // Handle links
                html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" class="text-primary hover:underline">$1</a>');
                
                // Handle blockquotes
                html = html.replace(/^>\s*(.*?)$/gm, '<blockquote class="border-l-4 border-gray-300 pl-3 italic">$1</blockquote>');
                
                return html;
            }
            
            // Show polish error
            function showPolishError(message) {
                polishErrorMessage.textContent = message;
                polishError.classList.remove('hidden');
            }
            
            // Copy polished paper to clipboard
            copyPolishedPaperBtn.addEventListener('click', function() {
                // Copy the text
                const text = polishedPaperContainer.textContent;
                
                try {
                    navigator.clipboard.writeText(text).then(() => {
                        // Show success feedback
                        const originalText = copyPolishedPaperBtn.innerHTML;
                        copyPolishedPaperBtn.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                            </svg>
                            Copied!
                        `;
                        setTimeout(() => {
                            copyPolishedPaperBtn.innerHTML = originalText;
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy text: ', err);
                        alert('Failed to copy text. Please try again or copy manually.');
                    });
                } catch (err) {
                    // Fallback for browsers that don't support clipboard API
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';  // Avoid scrolling to bottom
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        // Show success feedback
                        const originalText = copyPolishedPaperBtn.innerHTML;
                        copyPolishedPaperBtn.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                            </svg>
                            Copied!
                        `;
                        setTimeout(() => {
                            copyPolishedPaperBtn.innerHTML = originalText;
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy text: ', err);
                        alert('Failed to copy text. Please try again or copy manually.');
                    }
                    
                    document.body.removeChild(textArea);
                }
            });
            // Elements
            const searchForm = document.getElementById('search-form');
            const queryInput = document.getElementById('query');
            const resultsCountSelect = document.getElementById('results-count');
            const dateRangeSelect = document.getElementById('date-range');
            const searchButton = document.getElementById('search-button');
            const searchButtonText = document.getElementById('search-button-text');
            const loadingElement = document.getElementById('loading');
            const resultsContainer = document.getElementById('results-container');
            const resultsList = document.getElementById('results-list');
            const resultStats = document.getElementById('result-stats');
            const totalResults = document.getElementById('total-results');
            const viewMoreContainer = document.getElementById('view-more-container');
            const viewMoreLink = document.getElementById('view-more-link');
            const noResults = document.getElementById('no-results');
            const errorContainer = document.getElementById('error-container');
            const errorMessage = document.getElementById('error-message');
            const arxivCheckbox = document.getElementById('arxiv-checkbox');
            const pubmedCheckbox = document.getElementById('pubmed-checkbox');
            const semanticCheckbox = document.getElementById('semantic-checkbox');
            const selectAllButton = document.getElementById('select-all');
            const clearAllButton = document.getElementById('clear-all');
            const databaseMessage = document.getElementById('database-message');
            const paginationContainer = document.getElementById('pagination-container');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const currentPageSpan = document.getElementById('current-page');
            const totalPagesSpan = document.getElementById('total-pages');
            
            // Pagination state variables
            let currentPage = 1;
            let resultsPerPage = 10;
            let allSearchResults = [];
            let totalPagesCount = 1;
            
            // Current search database (arxiv, pubmed, or semantic)
            let currentDatabase = 'arxiv';
            
            // Base URLs for arXiv APIs
            const ARXIV_API_URL = 'https://export.arxiv.org/api/query';
            const ARXIV_SEARCH_URL = 'https://arxiv.org/search/?query=';
            const ARXIV_ARTICLE_URL = 'https://arxiv.org/abs/';
            
            // Base URLs for PubMed APIs
            const PUBMED_SEARCH_URL = 'https://pubmed.ncbi.nlm.nih.gov/?term=';
            const PUBMED_ARTICLE_URL = 'https://pubmed.ncbi.nlm.nih.gov/';
            
            // Base URLs for Semantic Scholar APIs
            const SEMANTIC_SCHOLAR_API_URL = 'https://api.semanticscholar.org/graph/v1/paper/search';
            const SEMANTIC_SCHOLAR_SEARCH_URL = 'https://www.semanticscholar.org/search?q=';
            const SEMANTIC_SCHOLAR_ARTICLE_URL = 'https://www.semanticscholar.org/paper/';
            
            // Pure JavaScript function to search arXiv directly using JSONP approach
            function searchArXiv(query, maxResults, dateRange) {
                return new Promise((resolve, reject) => {
                    try {
                        // Build date filter for arXiv API
                        let dateFilter = '';
                        if (dateRange !== 'all') {
                            // Calculate date range based on years ago
                            const yearsAgo = parseInt(dateRange, 10);
                            const today = new Date();
                            const pastDate = new Date();
                            pastDate.setFullYear(today.getFullYear() - yearsAgo);
                            
                            // Format dates as YYYY-MM-DD
                            const formattedPastDate = pastDate.toISOString().split('T')[0];
                            dateFilter = `&dateFrom=${formattedPastDate}`;
                        }
                        
                        // Build the arXiv API query
                        const encodedQuery = encodeURIComponent(query.replace(/\s+/g, '+'));
                        const arxivQueryUrl = `${ARXIV_API_URL}?search_query=all:${encodedQuery}&start=0&max_results=${maxResults}${dateFilter}&sortBy=submittedDate&sortOrder=descending`;
                        
                        console.log('Searching arXiv with query URL:', arxivQueryUrl);
                        
                        // Create a unique script ID and callback name for JSONP
                        const scriptId = 'arxiv_script_' + Date.now();
                        
                        // Create a script element to fetch data using JSONP
                        const script = document.createElement('script');
                        script.id = scriptId;
                        script.src = arxivQueryUrl;
                        
                        // Set a timeout for the request
                        const timeoutId = setTimeout(() => {
                            cleanupJSONP();
                            reject(new Error('arXiv API request timed out after 20 seconds'));
                        }, 20000);
                        
                        // Function to clean up the JSONP resources
                        function cleanupJSONP() {
                            clearTimeout(timeoutId);
                            if (document.getElementById(scriptId)) {
                                document.head.removeChild(document.getElementById(scriptId));
                            }
                        }
                        
                        // Handle script load error
                        script.onerror = () => {
                            cleanupJSONP();
                            console.error('JSONP request failed - trying alternative method');
                            
                            // If JSONP fails, try direct fetch which may work in some environments
                            fetchDirectlyWithFallback(arxivQueryUrl, resolve, reject);
                        };
                        
                        // Set up load event to capture the raw XML response
                        script.onload = () => {
                            cleanupJSONP();
                            
                            // In most cases, this won't succeed due to same-origin policy
                            // but we try anyway in case we're in a permissive environment
                            console.log('Script loaded - checking if we got data');
                            
                            // Since this likely won't work, we'll immediately try our fallback
                            fetchDirectlyWithFallback(arxivQueryUrl, resolve, reject);
                        };
                        
                        // Add the script to the document to initiate the request
                        document.head.appendChild(script);
                        
                    } catch (err) {
                        console.error('Error during arXiv search setup:', err);
                        reject(err);
                    }
                });
            }
            
            // Attempt to fetch directly with XMLHttpRequest as a fallback method
            function fetchDirectlyWithFallback(url, resolve, reject) {
                try {
                    console.log('Trying direct XMLHttpRequest without CORS...');
                    
                    // Create XMLHttpRequest object - can sometimes work where fetch fails
                    const xhr = new XMLHttpRequest();
                    
                    // Open a GET request to the arXiv API
                    xhr.open('GET', url, true);
                    
                    // Set response type to document to parse XML
                    xhr.responseType = 'document';
                    
                    // Set up handlers for success and failure
                    xhr.onload = function() {
                        if (xhr.status === 200) {
                            try {
                                const xmlDoc = xhr.responseXML;
                                
                                // Process the XML data
                                const result = processArXivXmlResponse(xmlDoc);
                                resolve(result);
                            } catch (error) {
                                console.error('Error processing XML response:', error);
                                
                                // Try parsing as text if XML parsing fails
                                tryParseAsText(xhr.responseText, resolve, reject);
                            }
                        } else {
                            console.error('XMLHttpRequest failed with status:', xhr.status);
                           
                        }
                    };
                    
                    xhr.onerror = function() {
                        console.error('XMLHttpRequest failed due to network error');
                       
                    };
                    
                    xhr.ontimeout = function() {
                        console.error('XMLHttpRequest timed out');
                        
                    };
                    
                    // Set a timeout
                    xhr.timeout = 10000;
                    
                    // Send the request
                    xhr.send();
                    
                } catch (err) {
                    console.error('Error in fetchDirectlyWithFallback:', err);
                     
                }
            }
            
            // Handle the case where we need to parse XML as text
            function tryParseAsText(xmlText, resolve, reject) {
                try {
                    // Create a new X2JS instance
                    const x2js = new X2JS();
                    
                    // Parse the XML text
                    const result = x2js.xml2js(xmlText);
                    
                    // Process the parsed XML and resolve
                    const processedData = processArXivJsonResult(result);
                    resolve(processedData);
                } catch (error) {
                    console.error('Failed to parse XML as text:', error);
                    reject(new Error('Failed to parse arXiv API response: ' + error.message));
                }
            }
            
            // Process XML response from arXiv
            function processArXivXmlResponse(xmlDoc) {
                try {
                    // Get the entries (papers) from the XML
                    const entries = xmlDoc.getElementsByTagName('entry');
                    const totalResultsNode = xmlDoc.getElementsByTagName('opensearch:totalResults')[0];
                    const totalResults = totalResultsNode ? parseInt(totalResultsNode.textContent, 10) : entries.length;
                    
                    const papers = Array.from(entries).map(entry => {
                        // Extract authors
                        const authorNodes = entry.getElementsByTagName('author');
                        const authors = Array.from(authorNodes).map(node => 
                            node.getElementsByTagName('name')[0]?.textContent || 'Unknown'
                        );
                        
                        // Extract categories
                        const categoryNodes = entry.getElementsByTagName('category');
                        const categories = Array.from(categoryNodes).map(node => 
                            node.getAttribute('term')
                        );
                        
                        // Get the arXiv ID from the ID field
                        const fullId = entry.getElementsByTagName('id')[0]?.textContent || '';
                        
                        // Complex pattern to match different arXiv ID formats
                        let id;
                        
                        // First try to match old-style IDs with category prefix (physics/0305100v2)
                        const oldStyleWithCategoryMatch = fullId.match(/arxiv\.org\/abs\/([-\w.]+\/\d+(?:v\d+)?)/i);
                        
                        // Then try new style IDs with version (2210.08282v1) or without (2210.08282)
                        const newStyleMatch = fullId.match(/arxiv\.org\/abs\/(\d+\.\d+(?:v\d+)?)/i);
                        
                        // Finally try to match old-style IDs without category (just numbers and version: 0305100v2)
                        const oldStyleWithoutCategoryMatch = fullId.match(/arxiv\.org\/abs\/(\d+(?:v\d+)?)/i);
                        
                        if (oldStyleWithCategoryMatch) {
                            // It's an old-style ID with category prefix (like physics/0305100v2)
                            id = oldStyleWithCategoryMatch[1];
                            console.log(`Found old-style ID with category: ${id}`);
                        } else if (newStyleMatch) {
                            // It's a new-style ID (like 2210.08282v1 or 2210.08282)
                            id = newStyleMatch[1];
                            console.log(`Found new-style ID: ${id}`);
                        } else if (oldStyleWithoutCategoryMatch) {
                            // It's an old-style ID without category prefix (like 0305100v2)
                            id = oldStyleWithoutCategoryMatch[1];
                            console.log(`Found old-style ID without category: ${id}`);
                        } else {
                            // Last resort - just get the last part of the URL
                            const lastPartMatch = fullId.match(/([^\/]+)$/);
                            id = lastPartMatch ? lastPartMatch[1] : 'unknown';
                            console.log(`Fallback ID extraction: ${id}`);
                        }
                        
                        // Extract other metadata
                        const title = entry.getElementsByTagName('title')[0]?.textContent || 'Untitled';
                        const summary = entry.getElementsByTagName('summary')[0]?.textContent || '';
                        const published = entry.getElementsByTagName('published')[0]?.textContent || '';
                        const updated = entry.getElementsByTagName('updated')[0]?.textContent || '';
                        
                        // Format the dates
                        const formattedPublished = formatArXivDate(published);
                        const formattedUpdated = formatArXivDate(updated);
                        
                        // Links
                        const arxiv_url = `https://arxiv.org/abs/${id}`;
                        // Create PDF URL with correct format based on ID type
                        // 1. If it's an old-style ID with category (physics/0305100v2), don't add .pdf extension
                        // 2. If it's a new-style ID with version (2210.08282v1), don't add .pdf extension
                        // 3. Otherwise, for new-style ID without version, add .pdf extension
                        const pdf_url = id.includes('/') || id.includes('v') ? 
                            `https://arxiv.org/pdf/${id}` : 
                            `https://arxiv.org/pdf/${id}.pdf`;
                        
                        return {
                            id,
                            title: formatArXivText(title),
                            authors,
                            summary: formatArXivText(summary),
                            published: formattedPublished,
                            updated: formattedUpdated,
                            categories,
                            doi: null, // arXiv API doesn't provide DOI
                            arxiv_url,
                            pdf_url
                        };
                    });
                    
                    return {
                        totalResults,
                        papers
                    };
                } catch (error) {
                    console.error('Error processing XML response:', error);
                    throw error;
                }
            }
            
            // Process the JSON result from X2JS conversion
            function processArXivJsonResult(result) {
                if (!result || !result.feed || !result.feed.entry) {
                    return {
                        totalResults: 0,
                        papers: []
                    };
                }
                
                // Get total results count
                const totalResults = result.feed['opensearch:totalResults'] ? 
                    parseInt(result.feed['opensearch:totalResults'], 10) : 0;
                
                // Ensure entries is always an array
                const entries = Array.isArray(result.feed.entry) ? 
                    result.feed.entry : [result.feed.entry];
                
                // Process each entry into our paper format
                const papers = entries.map(entry => {
                    // Extract authors
                    let authors = [];
                    if (entry.author) {
                        authors = Array.isArray(entry.author) ? 
                            entry.author.map(a => a.name) : 
                            [entry.author.name];
                    }
                    
                    // Extract categories
                    let categories = [];
                    if (entry.category) {
                        categories = Array.isArray(entry.category) ? 
                            entry.category.map(c => c._term) : 
                            [entry.category._term];
                    }
                    
                    // Extract arXiv ID from entry ID
                    const fullId = entry.id || '';
                    let id = 'unknown';
                    const idMatch = fullId.match(/([^\/]+)$/);
                    if (idMatch) {
                        id = idMatch[1];
                    }
                    
                    // Extract and format dates
                    const published = formatArXivDate(entry.published);
                    const updated = formatArXivDate(entry.updated);
                    
                    return {
                        id,
                        title: formatArXivText(entry.title),
                        authors,
                        summary: formatArXivText(entry.summary),
                        published,
                        updated,
                        categories,
                        doi: null, // arXiv API doesn't provide DOI
                        arxiv_url: `https://arxiv.org/abs/${id}`,
                        pdf_url: `https://arxiv.org/pdf/${id}.pdf`
                    };
                });
                
                return {
                    totalResults: totalResults || papers.length,
                    papers
                };
            }
            
             
            
            // Direct search for arXiv using CORS proxy technique
            function directArXivSearch(query, maxResults, dateRange) {
                return new Promise((resolve, reject) => {
                    try {
                        // Build date filter
                        let dateFilter = '';
                        if (dateRange !== 'all') {
                            const yearsAgo = parseInt(dateRange, 10);
                            const today = new Date();
                            const pastDate = new Date();
                            pastDate.setFullYear(today.getFullYear() - yearsAgo);
                            const formattedPastDate = pastDate.toISOString().split('T')[0];
                            dateFilter = `&dateFrom=${formattedPastDate}`;
                        }
                        
                        // Build the arXiv API query - this API typically allows CORS
                        const encodedQuery = encodeURIComponent(query.replace(/\s+/g, '+'));
                        const arxivQueryUrl = `${ARXIV_API_URL}?search_query=all:${encodedQuery}&start=0&max_results=${maxResults}${dateFilter}&sortBy=submittedDate&sortOrder=descending`;
                        
                        console.log('Direct arXiv API query:', arxivQueryUrl);
                        
                        // Use XMLHttpRequest for better control over response type
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', arxivQueryUrl, true);
                        
                        // Request XML document
                        xhr.responseType = 'document';
                        
                        xhr.onload = function() {
                            if (xhr.status === 200) {
                                try {
                                    // Get XML response
                                    const xmlDoc = xhr.responseXML;
                                    
                                    if (xmlDoc) {
                                        // Process XML document
                                        const result = processArXivXmlResponse(xmlDoc);
                                        resolve(result);
                                    } else {
                                        // If responseXML is null, try parsing as text
                                        const parser = new DOMParser();
                                        const xmlDoc = parser.parseFromString(xhr.responseText, 'application/xml');
                                        const result = processArXivXmlResponse(xmlDoc);
                                        resolve(result);
                                    }
                                } catch (error) {
                                    console.error('Error processing arXiv XML:', error);
                                    
                                    // Try parsing XML as text with x2js
                                    try {
                                        const x2js = new X2JS();
                                        const result = x2js.xml2js(xhr.responseText);
                                        const processedData = processArXivJsonResult(result);
                                        resolve(processedData);
                                    } catch (x2jsError) {
                                        reject(new Error('Failed to parse arXiv API response: ' + error.message));
                                    }
                                }
                            } else {
                                reject(new Error('arXiv API request failed with status: ' + xhr.status));
                            }
                        };
                        
                        xhr.onerror = function() {
                            reject(new Error('Network error when connecting to arXiv API'));
                        };
                        
                        xhr.ontimeout = function() {
                            reject(new Error('arXiv API request timed out'));
                        };
                        
                        // Set timeout
                        xhr.timeout = 15000;
                        
                        // Send the request
                        xhr.send();
                        
                    } catch (err) {
                        reject(err);
                    }
                });
            }
            
            // Direct search PubMed using native JavaScript
            function directPubMedSearch(query, maxResults, dateRange) {
                return new Promise((resolve, reject) => {
                    try {
                        // Build date filter for PubMed API
                        let dateFilter = '';
                        if (dateRange !== 'all') {
                            const yearsAgo = parseInt(dateRange, 10);
                            dateFilter = `&reldate=${yearsAgo * 365}`; // Convert years to days for PubMed
                        }
                        
                        // Build the PubMed eSearch API query to get IDs
                        const encodedQuery = encodeURIComponent(query);
                        const pubmedSearchUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&term=${encodedQuery}&retmax=${maxResults}${dateFilter}&sort=relevance&retmode=json`;
                        
                        console.log('Direct PubMed API search query:', pubmedSearchUrl);
                        
                        // First request to get IDs
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', pubmedSearchUrl, true);
                        xhr.responseType = 'json';
                        
                        xhr.onload = function() {
                            if (xhr.status === 200 && xhr.response) {
                                try {
                                    const searchResponse = xhr.response;
                                    const idList = searchResponse.esearchresult?.idlist || [];
                                    const totalResults = parseInt(searchResponse.esearchresult?.count || '0', 10);
                                    
                                    if (idList.length === 0) {
                                        // No results found
                                        resolve({
                                            totalResults: 0,
                                            papers: []
                                        });
                                        return;
                                    }
                                    
                                    // Get summaries and abstracts in parallel
                                    // 1. Fetch summaries using esummary 
                                    const summaryPromise = new Promise((resolveSum, rejectSum) => {
                                        const pubmedDetailUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&id=${idList.join(',')}&retmode=json`;
                                        
                                        const detailXhr = new XMLHttpRequest();
                                        detailXhr.open('GET', pubmedDetailUrl, true);
                                        detailXhr.responseType = 'json';
                                        
                                        detailXhr.onload = function() {
                                            if (detailXhr.status === 200 && detailXhr.response) {
                                                resolveSum(detailXhr.response);
                                            } else {
                                                rejectSum(new Error('PubMed summary request failed with status: ' + detailXhr.status));
                                            }
                                        };
                                        
                                        detailXhr.onerror = function() {
                                            rejectSum(new Error('Network error when fetching PubMed details'));
                                        };
                                        
                                        detailXhr.timeout = 15000;
                                        detailXhr.send();
                                    });
                                    
                                    // 2. Fetch abstracts using efetch
                                    const abstractPromise = new Promise((resolveAbs, rejectAbs) => {
                                        // Use efetch to get detailed XML with abstracts
                                        const pubmedAbstractUrl = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=pubmed&id=${idList.join(',')}&retmode=xml`;
                                        
                                        const abstractXhr = new XMLHttpRequest();
                                        abstractXhr.open('GET', pubmedAbstractUrl, true);
                                        abstractXhr.responseType = 'document'; // XML document
                                        
                                        abstractXhr.onload = function() {
                                            if (abstractXhr.status === 200 && abstractXhr.responseXML) {
                                                resolveAbs(abstractXhr.responseXML);
                                            } else {
                                                console.warn('Could not fetch PubMed abstracts as XML', abstractXhr.status);
                                                // Not rejecting because we can still use summary data
                                                resolveAbs(null); 
                                            }
                                        };
                                        
                                        abstractXhr.onerror = function() {
                                            console.warn('Network error when fetching PubMed abstracts');
                                            resolveAbs(null); // Not rejecting the whole process
                                        };
                                        
                                        abstractXhr.timeout = 15000;
                                        abstractXhr.send();
                                    });
                                    
                                    // Wait for both requests to complete
                                    Promise.all([summaryPromise, abstractPromise])
                                        .then(([summaryResponse, abstractXml]) => {
                                            try {
                                                // Extract abstracts from XML
                                                const abstractsMap = extractAbstractsFromXml(abstractXml, idList);
                                                
                                                // Process summary data and add abstracts
                                                const result = processPubMedJsonResponse(
                                                    summaryResponse, 
                                                    idList, 
                                                    totalResults,
                                                    abstractsMap
                                                );
                                                
                                                resolve(result);
                                            } catch (error) {
                                                console.error('Error processing PubMed data:', error);
                                                reject(new Error('Failed to process PubMed data: ' + error.message));
                                            }
                                        })
                                        .catch(error => {
                                            console.error('Error fetching PubMed data:', error);
                                            reject(error);
                                        });
                                    
                                } catch (error) {
                                    console.error('Error processing PubMed search response:', error);
                                    reject(new Error('Failed to process PubMed search results: ' + error.message));
                                }
                            } else {
                                reject(new Error('PubMed search request failed with status: ' + xhr.status));
                            }
                        };
                        
                        xhr.onerror = function() {
                            reject(new Error('Network error when connecting to PubMed API'));
                        };
                        
                        xhr.timeout = 15000;
                        xhr.send();
                        
                    } catch (err) {
                        reject(err);
                    }
                });
            }
            
            // Helper function to extract abstracts from PubMed XML response
            function extractAbstractsFromXml(xmlDoc, idList) {
                const abstractsMap = new Map();
                
                if (!xmlDoc) return abstractsMap;
                
                try {
                    // Get all PubmedArticle elements
                    const articles = xmlDoc.getElementsByTagName('PubmedArticle');
                    
                    // Process each article
                    for (let i = 0; i < articles.length; i++) {
                        const article = articles[i];
                        
                        // Get PMID
                        const pmidElement = article.querySelector('PMID');
                        if (!pmidElement) continue;
                        
                        const pmid = pmidElement.textContent;
                        
                        // Get abstract - try different possible paths
                        let abstractText = '';
                        
                        // Get all AbstractText elements
                        const abstractElements = article.querySelectorAll('Abstract AbstractText');
                        if (abstractElements.length > 0) {
                            // Concatenate all abstract sections
                            abstractText = Array.from(abstractElements)
                                .map(element => {
                                    // Check if there's a label attribute
                                    const label = element.getAttribute('Label') || element.getAttribute('NlmCategory');
                                    return label ? `${label}: ${element.textContent}` : element.textContent;
                                })
                                .join('\n\n');
                        } else {
                            // Try alternative paths
                            const singleAbstractElement = article.querySelector('AbstractText');
                            if (singleAbstractElement) {
                                abstractText = singleAbstractElement.textContent;
                            }
                        }
                        
                        // If we found an abstract, add it to the map
                        if (abstractText.trim()) {
                            abstractsMap.set(pmid, abstractText);
                            console.log(`Found abstract for PMID ${pmid}: ${abstractText.substring(0, 50)}...`);
                        } else {
                            console.log(`No abstract found for PMID ${pmid}`);
                        }
                    }
                    
                } catch (error) {
                    console.error('Error extracting abstracts from XML:', error);
                }
                
                return abstractsMap;
            }
            
            // Process PubMed JSON response from the E-utilities API
            function processPubMedJsonResponse(response, idList, totalResults, abstractsMap) {
                try {
                    const papers = [];
                    const result = response.result || {};
                    
                    // Process each PubMed article by ID
                    idList.forEach(pmid => {
                        const article = result[pmid];
                        if (!article) return;
                        
                        // Extract publication date
                        const pubDate = article.pubdate || '';
                        
                        // Extract authors
                        const authors = (article.authors || [])
                            .filter(author => author.name !== 'et al.')
                            .map(author => author.name || '');
                        
                        // Extract DOI (try multiple potential locations)
                        let doi = null;
                        if (article.elocationid && article.elocationid.startsWith('doi:')) {
                            doi = article.elocationid.replace('doi: ', '').trim();
                        } else if (article.articleids) {
                            const doiObj = article.articleids.find(id => id.idtype === 'doi');
                            if (doiObj) {
                                doi = doiObj.value;
                            }
                        }
                        
                        // Extract volume, issue, pages
                        const volume = article.volume || '';
                        const issue = article.issue || '';
                        const pages = article.pages || '';
                        
                        // First check if we have an abstract from the XML fetch
                        let abstract = '';
                        if (abstractsMap && abstractsMap.has(pmid)) {
                            abstract = abstractsMap.get(pmid);
                            console.log(`Using abstract from XML for ${pmid}`);
                        } else {
                            // Try multiple ways to get the abstract from the summary data
                            if (article.abstract) {
                                abstract = article.abstract;
                            } else if (typeof article.abstracttext === 'string') {
                                abstract = article.abstracttext;
                            } else if (Array.isArray(article.abstracttext)) {
                                // Sometimes abstracttext is an array of sections
                                abstract = article.abstracttext.join(' ');
                            } else if (article.description) {
                                abstract = article.description;
                            }
                        }
                        
                        // If still no abstract, log it
                        if (!abstract) {
                            console.log(`No abstract found for ${pmid} in either XML or summary data`);
                        }
                        
                        // Get full text links
                        let fullTextLinks = [];
                        
                        // Check for direct full text URLs in the articleids
                        if (article.articleids) {
                            const pmcObj = article.articleids.find(id => id.idtype === 'pmc');
                            if (pmcObj && pmcObj.value) {
                                const pmcId = pmcObj.value.replace('PMC', '');
                                fullTextLinks.push({
                                    name: 'PubMed Central (Full Text)',
                                    url: `https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${pmcId}/`
                                });
                            }
                        }
                        
                        // Add DOI-based link if we have a DOI
                        if (doi) {
                            fullTextLinks.push({
                                name: 'Publisher Site (via DOI)',
                                url: `https://doi.org/${doi}`
                            });
                        }
                        
                        // Standard PubMed link
                        fullTextLinks.push({
                            name: 'PubMed Record',
                            url: `https://pubmed.ncbi.nlm.nih.gov/${pmid}/`
                        });
                        
                        // Create paper object
                        const paper = {
                            id: pmid,
                            title: article.title || 'No Title Available',
                            authors: authors.length > 0 ? authors : ['No authors listed'],
                            journal: article.fulljournalname || article.source || '',
                            published: pubDate,
                            volume: volume,
                            issue: issue,
                            pages: pages,
                            doi: doi,
                            summary: abstract, // Store the abstract in the summary field
                            abstract: abstract, // Also store in abstract field for consistency
                            keywords: article.keywords || [],
                            pubmed_url: `https://pubmed.ncbi.nlm.nih.gov/${pmid}/`,
                            fullTextLinks: fullTextLinks
                        };
                        
                        // Log for debugging
                        console.log(`PubMed paper ${pmid} has abstract: ${abstract ? 'yes' : 'no'}, full text links: ${fullTextLinks.length}`);
                        
                        papers.push(paper);
                    });
                    
                    return {
                        totalResults: totalResults,
                        papers: papers
                    };
                } catch (error) {
                    console.error('Error processing PubMed data:', error);
                    throw new Error('Failed to process PubMed data: ' + error.message);
                }
            }
            
            // Helper functions for parsing arXiv data
            function formatArXivDate(dateStr) {
                if (!dateStr) return '';
                try {
                    const date = new Date(dateStr);
                    return date.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                } catch (e) {
                    return dateStr;
                }
            }
            
            function formatArXivText(text) {
                if (!text) return '';
                // Remove extra whitespace
                return text.replace(/\s+/g, ' ').trim();
            }
            
            // Fallback parser in case of text format
            function parseArXivDataFromText(text, maxResults) {
                const papers = [];
                const titleRegex = /Title:\s*(.*?)(?=\n|$)/g;
                const authorRegex = /Authors?:\s*(.*?)(?=\n|$)/g;
                const summaryRegex = /Abstract:\s*(.*?)(?=\n\n|$)/gs;
                const idRegex = /arXiv:(\d+\.\d+)/g;
                const categoryRegex = /Categories:\s*(.*?)(?=\n|$)/g;
                const dateRegex = /Published:\s*(.*?)(?=\n|$)/g;
                
                let match;
                let count = 0;
                let currentIndex = 0;
                
                // Find paper sections in the text
                const paperSections = text.split(/\n\s*\d+\.\s*/).filter(s => s.trim().length > 0).slice(0, maxResults);
                
                paperSections.forEach((section, index) => {
                    if (count >= maxResults) return;
                    
                    const id = (section.match(idRegex) || ['unknown'])[0].replace('arXiv:', '');
                    const title = ((section.match(titleRegex) || [''])[0] || '').replace('Title:', '').trim();
                    const authorsMatch = section.match(authorRegex);
                    const authors = authorsMatch ? 
                        authorsMatch[0].replace(/Authors?:/, '').split(',').map(a => a.trim()) : 
                        ['Unknown'];
                    const summary = ((section.match(summaryRegex) || [''])[0] || '').replace('Abstract:', '').trim();
                    const categoriesMatch = section.match(categoryRegex);
                    const categories = categoriesMatch ? 
                        categoriesMatch[0].replace('Categories:', '').split(',').map(c => c.trim()) : 
                        [];
                    const dateMatch = section.match(dateRegex);
                    const published = dateMatch ? dateMatch[0].replace('Published:', '').trim() : '';
                    
                    papers.push({
                        id,
                        title,
                        authors,
                        summary,
                        published,
                        updated: '',
                        categories,
                        doi: null,
                        arxiv_url: `https://arxiv.org/abs/${id}`,
                        pdf_url: `https://arxiv.org/pdf/${id}.pdf`
                    });
                    
                    count++;
                });
                
                return {
                    totalResults: papers.length,
                    papers
                };
            }
            
            // Display PubMed search results
            function displayPubMedResults(data) {
                resultsList.innerHTML = '';
                
                // Get papers from the data
                const papers = data.papers || [];
                
                if (papers.length === 0) {
                    showNoResults();
                    return;
                }
                
                papers.forEach(paper => {
                    if (!paper) return;
                    
                    // Create result card
                    const resultCard = document.createElement('div');
                    resultCard.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-md';
                    
                    // Format authors list
                    let authors = 'Unknown authors';
                    if (paper.authors && paper.authors.length > 0) {
                        authors = paper.authors.join(', ');
                    }
                    
                    // Format journal and publication date
                    let journalInfo = '';
                    if (paper.journal) {
                        journalInfo = `
                            <p class="text-sm mb-1"><span class="font-medium">Journal:</span> ${paper.journal}</p>
                        `;
                    }
                    
                    // Format keywords if available
                    let keywordsHtml = '';
                    if (paper.keywords && paper.keywords.length > 0) {
                        const keywords = paper.keywords.map(keyword => {
                            return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${keyword}</span>`;
                        }).join(' ');
                        
                        keywordsHtml = `
                            <div class="text-sm mb-3">
                                <p class="font-medium mb-1">Keywords:</p>
                                <div class="flex flex-wrap">${keywords}</div>
                            </div>
                        `;
                    }
                    
                    // Create DOI link if available
                    let doiLink = '';
                    if (paper.doi) {
                        doiLink = `
                            <div class="text-sm mb-1">
                                <span class="font-medium">DOI: </span>
                                <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                            </div>
                        `;
                    }
                    
                    // Format publication date
                    const publishedDate = paper.published || 'Unknown date';
                    
                    // Add abstract if available
                    let abstractHtml = '';
                    if (paper.summary) {
                        abstractHtml = `
                            <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                                <p class="font-medium mb-1">Abstract:</p>
                                <p class="text-sm text-gray-700 dark:text-gray-300">${paper.summary}</p>
                            </div>
                        `;
                    }
                    
                    // Build the article HTML with PubMed-specific links
                    resultCard.innerHTML = `
                        <h3 class="text-lg font-semibold text-primary mb-2">${paper.title || 'Untitled'}</h3>
                        <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                        ${journalInfo}
                        <p class="text-sm mb-1"><span class="font-medium">Published:</span> ${publishedDate}</p>
                        <p class="text-sm mb-1"><span class="font-medium">PMID:</span> ${paper.id}</p>
                        ${doiLink}
                        ${keywordsHtml}
                        ${abstractHtml}
                        <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <a href="${paper.pubmed_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                                </svg>
                                View on PubMed
                            </a>
                            ${paper.doi ? `
                            <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                                </svg>
                                View via DOI
                            </a>
                            ` : ''}
                        </div>
                    `;
                    
                    resultsList.appendChild(resultCard);
                });
                
                showResults();
            }
            
            // Display Semantic Scholar search results
            function displaySemanticScholarResults(data) {
                resultsList.innerHTML = '';
                
                // Get papers from the data
                const papers = data.papers || [];
                
                if (papers.length === 0) {
                    showNoResults();
                    return;
                }
                
                papers.forEach(paper => {
                    if (!paper) return;
                    
                    // Create result card
                    const resultCard = document.createElement('div');
                    resultCard.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-md';
                    
                    // Format authors list
                    let authors = 'Unknown authors';
                    if (paper.authors && paper.authors.length > 0) {
                        authors = paper.authors.join(', ');
                    }
                    
                    // Format fields/topics into a nice display
                    let fieldsHtml = '';
                    if (paper.fields && paper.fields.length > 0) {
                        const fields = paper.fields.map(field => {
                            return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${field}</span>`;
                        }).join(' ');
                        
                        fieldsHtml = `
                            <div class="text-sm mb-3">
                                <p class="font-medium mb-1">Fields of Study:</p>
                                <div class="flex flex-wrap">${fields}</div>
                            </div>
                        `;
                    }
                    
                    // Format venue/publication info
                    let venueInfo = '';
                    if (paper.venue) {
                        venueInfo = `
                            <p class="text-sm mb-1"><span class="font-medium">Venue:</span> ${paper.venue}</p>
                        `;
                    }
                    
                    // Create DOI link if available
                    let doiLink = '';
                    if (paper.doi) {
                        doiLink = `
                            <div class="text-sm mb-1">
                                <span class="font-medium">DOI: </span>
                                <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                            </div>
                        `;
                    }
                    
                    // Format publication year
                    const year = paper.year || 'Unknown year';
                    
                    // Format citation count
                    let citationInfo = '';
                    if (paper.citationCount !== undefined) {
                        citationInfo = `
                            <p class="text-sm mb-1"><span class="font-medium">Citations:</span> ${paper.citationCount}</p>
                        `;
                    }
                    
                    // Add abstract if available
                    let abstractHtml = '';
                    if (paper.abstract) {
                        abstractHtml = `
                            <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                                <p class="font-medium mb-1">Abstract:</p>
                                <p class="text-sm text-gray-700 dark:text-gray-300">${paper.abstract}</p>
                            </div>
                        `;
                    }
                    
                    // Build the article HTML with Semantic Scholar-specific links
                    resultCard.innerHTML = `
                        <h3 class="text-lg font-semibold text-primary mb-2">${paper.title || 'Untitled'}</h3>
                        <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                        ${venueInfo} 
                        <p class="text-sm mb-1"><span class="font-medium">Year:</span> ${year}</p>
                        ${citationInfo}
                        
                        <p class="text-sm mb-1"><span class="font-medium">Semantic Scholar ID:</span> ${paper.paperId || 'Unknown'}</p>
                        ${doiLink}
                        ${fieldsHtml}
                        ${abstractHtml}
                        <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <a href="${paper.url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                                </svg>
                                View on Semantic Scholar
                            </a>
                            ${paper.doi ? `
                            <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                                </svg>
                                View via DOI
                            </a>
                            ` : ''}
                            ${paper.pdfUrl ? `
                            <a href="${paper.pdfUrl}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                </svg>
                                PDF
                            </a>
                            ` : ''}
                        </div>
                    `;
                    
                    resultsList.appendChild(resultCard);
                });
                
                showResults();
            }
            
            // Display arXiv search results
            function displayArXivResults(data) {
                resultsList.innerHTML = '';
                
                // Get papers from the data
                const papers = data.papers || [];
                
                if (papers.length === 0) {
                    showNoResults();
                    return;
                }
                
                papers.forEach(paper => {
                    if (!paper) return;
                    
                    // Create result card
                    const resultCard = document.createElement('div');
                    resultCard.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-md';
                    
                    // Format authors list
                    let authors = 'Unknown authors';
                    if (paper.authors && paper.authors.length > 0) {
                        authors = paper.authors.join(', ');
                    }
                    
                    // Format categories into a nice display
                    let categoriesHtml = '';
                    if (paper.categories && paper.categories.length > 0) {
                        const categories = paper.categories.map(cat => {
                            return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${cat}</span>`;
                        }).join(' ');
                        
                        categoriesHtml = `
                            <div class="text-sm mb-3">
                                <p class="font-medium mb-1">Categories:</p>
                                <div class="flex flex-wrap">${categories}</div>
                            </div>
                        `;
                    }
                    
                    // Create DOI link if available
                    let doiLink = '';
                    if (paper.doi) {
                        doiLink = `
                            <div class="text-sm mb-1">
                                <span class="font-medium">DOI: </span>
                                <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                            </div>
                        `;
                    }
                    
                    // Format dates
                    const publishedDate = paper.published || 'Unknown date';
                    const updatedDate = paper.updated || '';
                    let updatedInfo = '';
                    if (updatedDate && updatedDate !== publishedDate) {
                        updatedInfo = `<p class="text-sm mb-1"><span class="font-medium">Updated:</span> ${updatedDate}</p>`;
                    }
                    
                    // Add summary/abstract if available
                    let abstractHtml = '';
                    if (paper.summary) {
                        abstractHtml = `
                            <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                                <p class="font-medium mb-1">Abstract:</p>
                                <p class="text-sm text-gray-700 dark:text-gray-300">${paper.summary}</p>
                            </div>
                        `;
                    }
                    
                    // Build the article HTML with arXiv-specific links
                    resultCard.innerHTML = `
                        <h3 class="text-lg font-semibold text-primary mb-2">${paper.title || 'Untitled'}</h3>
                        <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                        <p class="text-sm mb-1"><span class="font-medium">Published:</span> ${publishedDate}</p>
                        ${updatedInfo}
                        <p class="text-sm mb-1"><span class="font-medium">arXiv ID:</span> ${paper.id}</p>
                        ${doiLink}
                        ${categoriesHtml}
                        ${abstractHtml}
                        <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <a href="${paper.arxiv_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                                </svg>
                                arXiv Abstract
                            </a>
                            <a href="${paper.pdf_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                </svg>
                                PDF
                            </a>
                        </div>
                    `;
                    
                    resultsList.appendChild(resultCard);
                });
                
                showResults();
            }
            
            // Function to search Semantic Scholar API using native JavaScript
            function directSemanticScholarSearch(query, maxResults, dateRange) {
                return new Promise((resolve, reject) => {
                    try {
                        // Build date filter for Semantic Scholar API
                        let yearFilter = '';
                        if (dateRange !== 'all') {
                            const yearsAgo = parseInt(dateRange, 10);
                            const currentYear = new Date().getFullYear();
                            const startYear = currentYear - yearsAgo;
                            yearFilter = `&year=${startYear}:${currentYear}`;
                        }
                        
                        // Build the Semantic Scholar API query
                        const semanticScholarUrl = `https://api.semanticscholar.org/graph/v1/paper/search?query=${encodeURIComponent(query)}&limit=${maxResults}${yearFilter}&fields=title,authors,year,venue,url,abstract,citationCount,externalIds,journal,fieldsOfStudy,publicationTypes,publicationDate`;
                        
                        console.log('Direct Semantic Scholar API query:', semanticScholarUrl);
                        
                        // Create and send request
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', semanticScholarUrl, true);
                        xhr.responseType = 'json';
                        
                        xhr.onload = function() {
                            if (xhr.status === 200 && xhr.response) {
                                try {
                                    const response = xhr.response;
                                    const result = processSemanticScholarResponse(response);
                                    resolve(result);
                                } catch (error) {
                                    console.error('Error processing Semantic Scholar response:', error);
                              
                                }
                            } else {
                                console.error('Semantic Scholar API request failed with status:', xhr.status);
                                
                            }
                        };
                        
                        xhr.onerror = function() {
                            console.error('Network error when connecting to Semantic Scholar API');
                           
                        };
                        
                        xhr.ontimeout = function() {
                            console.error('Semantic Scholar API request timed out');
                           
                        };
                        
                        // Set timeout
                        xhr.timeout = 15000;
                        
                        // Send the request
                        xhr.send();
                        
                    } catch (err) {
                        console.error('Error in Semantic Scholar search:', err);
                         
                    }
                });
            }
            
            // Process Semantic Scholar API response
            function processSemanticScholarResponse(response) {
                try {
                    const data = response.data || [];
                    const total = response.total || data.length;
                    
                    const papers = data.map(paper => {
                        // Extract authors
                        const authors = (paper.authors || []).map(author => author.name || 'Unknown');
                        
                        // Extract DOI
                        let doi = null;
                        if (paper.externalIds && paper.externalIds.DOI) {
                            doi = paper.externalIds.DOI;
                        }
                        
                        // Get PDF URL if available
                        let pdfUrl = null;
                        if (paper.openAccessPdf && paper.openAccessPdf.url) {
                            pdfUrl = paper.openAccessPdf.url;
                        }
                        
                        // Use publication date if available, otherwise fall back to year
                        let year = paper.year;
                        if (paper.publicationDate) {
                            // Extract year from publication date
                            const dateMatch = paper.publicationDate.match(/^(\d{4})/);
                            if (dateMatch) {
                                year = parseInt(dateMatch[1], 10);
                            }
                        }
                        
                        // Prefer journal over venue if available
                        // Handle venue when it's returned as an object
                        let venueStr = '';
                        if (paper.venue) {
                            if (typeof paper.venue === 'object') {
                                // If venue is an object, try to get name or other text property
                                venueStr = paper.venue.name || paper.venue.text || paper.venue.title || JSON.stringify(paper.venue);
                            } else {
                                venueStr = paper.venue;
                            }
                        }
                        const venue = paper.journal.name || venueStr || '';
                        
                        // Create paper object
                        return {
                            paperId: paper.paperId || 'unknown',
                            title: paper.title || 'Untitled',
                            authors: authors,
                            volume: paper.journal.volume,                            
                            year: year,
                            venue: venue,
                            abstract: paper.abstract || '',
                            citationCount: paper.citationCount,
                            fields: paper.fieldsOfStudy || [],
                            doi: doi,
                            url: paper.url || `${SEMANTIC_SCHOLAR_ARTICLE_URL}${paper.paperId}`,
                            pdfUrl: pdfUrl,
                            publicationDate: paper.publicationDate || null
                        };
                    });
                    
                    return {
                        totalResults: total,
                        papers: papers
                    };
                } catch (error) {
                    console.error('Error processing Semantic Scholar data:', error);
                    throw new Error('Failed to process Semantic Scholar data: ' + error.message);
                }
            }
            
             
            
            // Generic function to search a specific database and return results
            async function searchDatabase(database, query, maxResults, dateRange) {
                console.log(`Starting ${database} search for:`, query);
                
                try {
                    let data;
                    
                    if (database === 'arXiv') {
                        // Try multiple methods in sequence until one succeeds
                        try {
                            // First try the direct CORS method
                            data = await directArXivSearch(query, maxResults, dateRange);
                        } catch (directError) {
                            console.error('Direct arXiv search failed:', directError);
                            
                            // Next try XMLHttpRequest
                            try {
                                const arxivQueryUrl = `${ARXIV_API_URL}?search_query=all:${encodeURIComponent(query.replace(/\s+/g, '+'))}&start=0&max_results=${maxResults}&sortBy=submittedDate&sortOrder=descending`;
                                data = await new Promise((resolve, reject) => {
                                    fetchDirectlyWithFallback(arxivQueryUrl, resolve, reject);
                                });
                            } catch (xhrError) {
                                console.error('XMLHttpRequest arXiv search failed:', xhrError);
                                
                                // If all else fails, try the old JSONP approach
                                data = await searchArXiv(query, maxResults, dateRange);
                            }
                        }
                    } else if (database === 'PubMed') {
                        // Use direct API to fetch PubMed data
                        data = await directPubMedSearch(query, maxResults, dateRange);
                    } else if (database === 'Semantic Scholar') {
                        // Use direct API to fetch Semantic Scholar data
                        data = await directSemanticScholarSearch(query, maxResults, dateRange);
                    }
                    
                    console.log(`${database} search results received:`, data ? 'yes' : 'no');
                    
                    if (!data) {
                        throw new Error(`No response from ${database} search API`);
                    }
                    
                    // Add source information to each paper
                    if (data.papers && data.papers.length > 0) {
                        data.papers.forEach(paper => {
                            paper.source = database;
                        });
                    }
                    
                    return {
                        success: true,
                        data: data,
                        source: database
                    };
                } catch (error) {
                    console.error(`${database} search error:`, error);
                    return {
                        success: false,
                        error: error.message,
                        source: database
                    };
                }
            }
            
            // Display combined results from multiple databases with pagination
            function displayCombinedResults(results) {
                resultsList.innerHTML = '';
                
                // Clear selected papers for new search
                selectedPapers.clear();
                
                // Count total results across all sources
                let totalResultsCount = 0;
                allSearchResults = [];
                let sourcesWithResults = [];
                
                // Process successful results
                results.forEach(result => {
                    if (result.success && result.data && result.data.papers && result.data.papers.length > 0) {
                        totalResultsCount += result.data.totalResults;
                        allSearchResults = allSearchResults.concat(result.data.papers);
                        sourcesWithResults.push(result.source);
                    }
                });
                
                // If no results across all sources, show no results message
                if (allSearchResults.length === 0) {
                    showNoResults();
                    return;
                }
                
                // Add all papers to selected papers by default
                allSearchResults.forEach(paper => {
                    const paperId = paper.source + '-' + (paper.id || paper.paperId);
                    selectedPapers.set(paperId, paper);
                });
                
                // Update selection toolbar
                updateSelectionToolbar();
                
                // Update total results count
                totalResults.textContent = totalResultsCount;
                
                // Query info for later use if needed
                const query = queryInput.value.trim();
                const encodedQuery = encodeURIComponent(query);
                
                // Set up pagination
                resultsPerPage = parseInt(resultsCountSelect.value, 10);
                currentPage = 1;
                totalPagesCount = Math.ceil(allSearchResults.length / resultsPerPage);
                
                // Update pagination UI
                updatePaginationUI();
                
                // Display first page of results
                displayResultsPage(currentPage);
                
                showResults();
            }
            
            // Display a specific page of results
            function displayResultsPage(pageNum) {
                resultsList.innerHTML = '';
                
                // Calculate start and end indices for the current page
                const startIndex = (pageNum - 1) * resultsPerPage;
                const endIndex = Math.min(startIndex + resultsPerPage, allSearchResults.length);
                
                // Get papers for the current page
                const papersForPage = allSearchResults.slice(startIndex, endIndex);
                
                // Process and display each paper
                papersForPage.forEach(paper => {
                    // Create result card with source badge
                    const resultCard = document.createElement('div');
                    resultCard.className = 'bg-white dark:bg-gray-800 p-5 rounded-lg shadow-md relative';
                    
                    // Add source badge
                    const sourceBadgeColor = paper.source === 'arXiv' ? 'bg-blue-500' : 
                                             paper.source === 'PubMed' ? 'bg-green-500' : 
                                             'bg-purple-500';
                    
                    const sourceBadge = `
                        <div class="absolute top-0 right-0 ${sourceBadgeColor} text-white text-xs font-bold px-2 py-1 rounded-bl-lg rounded-tr-lg">
                            ${paper.source}
                        </div>
                    `;
                    
                    // Add matched query keyword badge if available
                    let keywordBadge = '';
                    if (paper.matchedQuery) {
                        keywordBadge = `
                            <div class="absolute top-0 left-0 bg-yellow-500 text-white text-xs font-bold px-2 py-1 rounded-br-lg rounded-tl-lg">
                                Matched: "${paper.matchedQuery}"
                            </div>
                        `;
                    }
                    
                    // Render paper based on its source
                    let paperHtml = '';
                    if (paper.source === 'arXiv') {
                        paperHtml = renderArXivPaper(paper);
                    } else if (paper.source === 'PubMed') {
                        paperHtml = renderPubMedPaper(paper);
                    } else if (paper.source === 'Semantic Scholar') {
                        paperHtml = renderSemanticScholarPaper(paper);
                    }
                    
                    // Combine badges with paper content
                    resultCard.innerHTML = sourceBadge + keywordBadge + paperHtml;
                    resultsList.appendChild(resultCard);
                });
                
                // Scroll to top of results
                resultsContainer.scrollIntoView({ behavior: 'smooth' });
            }
            
            // Update pagination UI elements
            function updatePaginationUI() {
                // Update page indicators
                currentPageSpan.textContent = currentPage;
                totalPagesSpan.textContent = totalPagesCount;
                
                // Enable/disable prev/next buttons based on current page
                prevPageBtn.disabled = currentPage <= 1;
                nextPageBtn.disabled = currentPage >= totalPagesCount;
                
                // Always show pagination controls for better UI experience
                if (totalPagesCount <= 1) {
                    // If there's only one page, disable both buttons
                    prevPageBtn.disabled = true;
                    nextPageBtn.disabled = true;
                }
            }
            
            // Paper selection management
            let selectedPapers = new Map(); // Map to store selected papers by ID
            let mergedReferences = new Map(); // Map to store merged references across searches
            const selectionToolbar = document.getElementById('selection-toolbar');
            const selectedCount = document.getElementById('selected-count');
            const clearSelectionBtn = document.getElementById('clear-selection');
            const exportBibtexBtn = document.getElementById('export-bibtex');
            const bibtexModal = document.getElementById('bibtex-modal');
            const bibtexContent = document.getElementById('bibtex-content');
            const bibtexCount = document.getElementById('bibtex-count');
            const copyBibtexBtn = document.getElementById('copy-bibtex');
            const closeModalBtn = document.getElementById('close-modal');
            
            // Function to update the selection toolbar
            function updateSelectionToolbar() {
                const count = selectedPapers.size;
                selectedCount.textContent = count;
                
                if (count > 0) {
                    selectionToolbar.classList.remove('hidden');
                } else {
                    selectionToolbar.classList.add('hidden');
                }
            }
            
            // Function to toggle paper selection
            function togglePaperSelection(paper, checkbox) {
                const paperId = paper.source + '-' + (paper.id || paper.paperId);
                
                if (checkbox.checked) {
                    selectedPapers.set(paperId, paper);
                } else {
                    selectedPapers.delete(paperId);
                }
                
                updateSelectionToolbar();
            }
            
            // Clear all selections
            clearSelectionBtn.addEventListener('click', function() {
                selectedPapers.clear();
                
                // Update all checkboxes to unchecked
                document.querySelectorAll('.paper-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                updateSelectionToolbar();
            });
            
            // Generate BibTeX for arXiv paper
            function generateArXivBibTeX(paper) {
                const authors = paper.authors.join(' and ');
                const year = paper.published ? paper.published.split(' ')[2] : new Date().getFullYear();
                const title = paper.title.replace(/[{}]/g, '');
                
                // Get first word of title for citation key
                const firstTitleWord = title.split(/\s+/)[0].replace(/[^a-zA-Z0-9]/g, '');
                
                // Create a citation key using authoryear + first word of title format
                const firstAuthor = paper.authors.length > 0 ? paper.authors[0].split(' ').pop() : 'Unknown';
                const citeKey = `${firstAuthor}${year}${firstTitleWord}`;
                
                let bibtex = `@article{${citeKey},
  author = {${authors}},
  title = {{${title}}},
  year = {${year}},
  journal={arXiv},
  eprint = {${paper.id}},
  archivePrefix = {arXiv},`;
  
                if (paper.doi) {
                    bibtex += `\n  doi = {${paper.doi}},`;
                }
                
                if (paper.categories && paper.categories.length > 0) {
                    bibtex += `\n  primaryClass = {${paper.categories[0]}},`;
                }
                
                bibtex += `\n  url = {${paper.arxiv_url}},`;
                
                // Add PDF link
                bibtex += `\n  pdf = {${paper.pdf_url}}`;
                
                // Add abstract if available
                if (paper.summary) {
                    // Escape special characters and format for BibTeX
                    const cleanAbstract = paper.summary
                        .replace(/[{}]/g, '')
                        .replace(/[\n\r]/g, ' ')
                        .trim();
                    bibtex += `,\n  abstract = {${cleanAbstract}}`;
                }
                
                bibtex += `\n}`;
                
                return bibtex;
            }
            
            // Generate BibTeX for PubMed paper
            function generatePubMedBibTeX(paper) {
                const authors = paper.authors.join(' and ');
                
                // Extract year from published date - handle multiple possible formats
                let year;
                if (paper.published) {
                    // Try to extract year using regex to find 4-digit number
                    const yearMatch = paper.published.match(/\b(\d{4})\b/);
                    if (yearMatch && yearMatch[1]) {
                        year = yearMatch[1];
                    } else {
                        // Fallback to splitting by spaces (old method)
                        const parts = paper.published.split(' ');
                        year = parts.length >= 3 ? parts[2] : new Date().getFullYear();
                    }
                } else {
                    year = new Date().getFullYear();
                }
                
                const title = paper.title.replace(/[{}]/g, '');
                
                // Get first word of title for citation key
                const firstTitleWord = title.split(/\s+/)[0].replace(/[^a-zA-Z0-9]/g, '');
                
                // Create a citation key using authoryear + first word of title format
                const firstAuthor = paper.authors.length > 0 ? paper.authors[0].split(' ').pop() : 'Unknown';
                const citeKey = `${firstAuthor}${year}${firstTitleWord}`;
                
                let bibtex = `@article{${citeKey},
  author = {${authors}},
  title = {{${title}}},
  year = {${year}},`;
                
                // Add published date in the BibTeX
                if (paper.published) {
                    bibtex += `\n  published = {${paper.published}},`;
                }
  
                if (paper.journal) {
                    bibtex += `\n  journal = {${paper.journal}},`;
                }
                
                // Add volume, issue, and pages if available
                if (paper.volume && paper.volume.trim() !== '') {
                    bibtex += `\n  volume = {${paper.volume}},`;
                }
                
                if (paper.issue && paper.issue.trim() !== '') {
                    bibtex += `\n  number = {${paper.issue}},`;
                }
                
                if (paper.pages && paper.pages.trim() !== '') {
                    bibtex += `\n  pages = {${paper.pages}},`;
                }
                
                bibtex += `\n  pmid = {${paper.id}},`;
                
                if (paper.doi) {
                    bibtex += `\n  doi = {${paper.doi}},`;
                }
                
                bibtex += `\n  url = {${paper.pubmed_url}}`;
                
                // Add PDF link using PMC ID if available
                let hasPmcId = false;
                
                // Check for PMC ID in articleids
                if (paper.articleids) {
                    const pmcObj = paper.articleids.find(id => id.idtype === 'pmc');
                    if (pmcObj && pmcObj.value) {
                        const pmcId = pmcObj.value.replace('PMC', '');
                        const pmcPdfUrl = `https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${pmcId}/pdf`;
                        bibtex += `,\n  pdf = {${pmcPdfUrl}}`;
                        hasPmcId = true;
                    }
                }
                
                // If no PMC ID was found, try fullTextLinks as fallback
                if (!hasPmcId && paper.fullTextLinks && paper.fullTextLinks.length > 0) {
                    // Find PMC link first
                    const pmcLink = paper.fullTextLinks.find(link => 
                        link.name.includes('PubMed Central') || 
                        link.url.includes('ncbi.nlm.nih.gov/pmc')
                    );
                    
                    if (pmcLink) {
                        // Convert regular PMC link to PDF link format if needed
                        let pdfUrl = pmcLink.url;
                        if (!pdfUrl.endsWith('/pdf')) {
                            // Extract PMC ID from URL
                            const pmcMatch = pdfUrl.match(/PMC(\d+)/);
                            if (pmcMatch) {
                                pdfUrl = `https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${pmcMatch[1]}/pdf`;
                            } else {
                                pdfUrl = pdfUrl + '/pdf';
                            }
                        }
                        bibtex += `,\n  pdf = {${pdfUrl}}`;
                    } else {
                        // If no PMC link, use other PDF link types as last resort
                        const pdfLink = paper.fullTextLinks.find(link => 
                            link.name.includes('PDF') || 
                            link.name.includes('Full Text') || 
                            link.url.includes('.pdf')
                        );
                        
                        if (pdfLink) {
                            bibtex += `,\n  pdf = {${pdfLink.url}}`;
                        }
                    }
                }
                
                // Add abstract if available
                if (paper.summary) {
                    // Escape special characters and format for BibTeX
                    const cleanAbstract = paper.summary
                        .replace(/[{}]/g, '')
                        .replace(/[\n\r]/g, ' ')
                        .trim();
                    bibtex += `,\n  abstract = {${cleanAbstract}}`;
                }
                
                bibtex += `\n}`;
                
                return bibtex;
            }
            
            // Generate BibTeX for Semantic Scholar paper
            function generateSemanticScholarBibTeX(paper) {
                const authors = paper.authors.join(' and ');
                const year = paper.year || new Date().getFullYear();
                const title = paper.title.replace(/[{}]/g, '');
                
                // Get first word of title for citation key
                const firstTitleWord = title.split(/\s+/)[0].replace(/[^a-zA-Z0-9]/g, '');
                
                // Create a citation key using authoryear + first word of title format
                const firstAuthor = paper.authors.length > 0 ? paper.authors[0].split(' ').pop() : 'Unknown';
                const citeKey = `${firstAuthor}${year}${firstTitleWord}`;
                
                let bibtex = `@article{${citeKey},
  author = {${authors}},
  title = {{${title}}},
  year = {${year}},`;
               
                if (paper.venue) {
                    bibtex += `\n  journal = {${paper.venue}},`;                      
                    
                }
                if (paper.volume) {
                    bibtex += `\n  volume = {${paper.volume}},`;                      
                    
                }
      
                                       
                if (paper.doi) {
                    bibtex += `\n  doi = {${paper.doi}},`;
                }
                
                // Add citation count if available
                if (paper.citationCount !== undefined) {
                    bibtex += `\n  citations = {${paper.citationCount}},`;
                }
                
                bibtex += `\n  url = {${paper.url}}`;
                
                if (paper.pdfUrl) {
                    bibtex += `,\n  pdf = {${paper.pdfUrl}}`;
                }
                
                // Add abstract if available
                if (paper.abstract) {
                    // Escape special characters and format for BibTeX
                    const cleanAbstract = paper.abstract
                        .replace(/[{}]/g, '')
                        .replace(/[\n\r]/g, ' ')
                        .trim();
                    bibtex += `,\n  abstract = {${cleanAbstract}}`;
                }
                
                bibtex += `\n}`;
                
                return bibtex;
            }
            
            // Add merged references functionality
            const mergeRefsBtn = document.getElementById('merge-refs');
            const mergedCountSpan = document.getElementById('merged-count');
            const mergedCountButton = document.getElementById('merged-count-button');
            const exportMergedBibtexBtn = document.getElementById('export-merged-bibtex');
            const mergeNotification = document.getElementById('merge-notification');
            const clearMergedRefsBtn = document.getElementById('clear-merged-refs');
            
            // Update merged count display
            function updateMergedCount() {
                const count = mergedReferences.size;
                mergedCountSpan.textContent = count;
                mergedCountButton.textContent = count;
            }
            
            // Clear all merged references
            clearMergedRefsBtn.addEventListener('click', function() {
                mergedReferences.clear();
                updateMergedCount();
                
                // Update polishing section references list if it's open
                if (!paperPolishSection.classList.contains('hidden')) {
                    updatePolishReferencesList();
                }
                
                // Show notification
                mergeNotification.textContent = "Merged references cleared";
                mergeNotification.style.opacity = '1';
                setTimeout(() => {
                    mergeNotification.style.opacity = '0';
                    // Reset notification text after fade out
                    setTimeout(() => {
                        mergeNotification.textContent = "References added to merged list";
                    }, 500);
                }, 2000);
            });
            
            // Add selected papers to merged references
            mergeRefsBtn.addEventListener('click', function() {
                const papers = Array.from(selectedPapers.values());
                
                papers.forEach(paper => {
                    const paperId = paper.source + '-' + (paper.id || paper.paperId);
                    mergedReferences.set(paperId, paper);
                });
                
                // Update merged count
                updateMergedCount();
                
                // Show notification
                mergeNotification.style.opacity = '1';
                setTimeout(() => {
                    mergeNotification.style.opacity = '0';
                }, 2000);
            });
            
            // Export merged references as BibTeX
            exportMergedBibtexBtn.addEventListener('click', function() {
                const papers = Array.from(mergedReferences.values());
                
                if (papers.length === 0) {
                    alert('Please add some papers to the merged references first');
                    return;
                }
                
                let bibtexOutput = '';
                
                papers.forEach(paper => {
                    if (paper.source === 'arXiv') {
                        bibtexOutput += generateArXivBibTeX(paper) + '\n\n';
                    } else if (paper.source === 'PubMed') {
                        bibtexOutput += generatePubMedBibTeX(paper) + '\n\n';
                    } else if (paper.source === 'Semantic Scholar') {
                        bibtexOutput += generateSemanticScholarBibTeX(paper) + '\n\n';
                    }
                });
                
                // Update modal content
                bibtexContent.textContent = bibtexOutput;
                bibtexCount.textContent = papers.length;
                
                // Show the modal
                bibtexModal.classList.remove('hidden');
            });
            
            // Export selected papers as BibTeX
            exportBibtexBtn.addEventListener('click', function() {
                const papers = Array.from(selectedPapers.values());
                
                if (papers.length === 0) {
                    alert('Please select some papers first');
                    return;
                }
                
                let bibtexOutput = '';
                
                papers.forEach(paper => {
                    if (paper.source === 'arXiv') {
                        bibtexOutput += generateArXivBibTeX(paper) + '\n\n';
                    } else if (paper.source === 'PubMed') {
                        bibtexOutput += generatePubMedBibTeX(paper) + '\n\n';
                    } else if (paper.source === 'Semantic Scholar') {
                        bibtexOutput += generateSemanticScholarBibTeX(paper) + '\n\n';
                    }
                });
                
                // Update modal content
                bibtexContent.textContent = bibtexOutput;
                bibtexCount.textContent = papers.length;
                
                // Show the modal
                bibtexModal.classList.remove('hidden');
            });
            
            // Close the BibTeX modal
            closeModalBtn.addEventListener('click', function() {
                bibtexModal.classList.add('hidden');
            });
            
            // Copy BibTeX to clipboard
            copyBibtexBtn.addEventListener('click', function() {
                // Select the text
                const range = document.createRange();
                range.selectNodeContents(bibtexContent);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                // Copy to clipboard
                try {
                    document.execCommand('copy');
                    // Show success feedback
                    const originalText = copyBibtexBtn.innerHTML;
                    copyBibtexBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
                        </svg>
                        Copied!
                    `;
                    setTimeout(() => {
                        copyBibtexBtn.innerHTML = originalText;
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    alert('Failed to copy text. Please try again or copy manually.');
                }
                
                // Clear selection
                selection.removeAllRanges();
            });
            
            // Close modal when clicking outside
            bibtexModal.addEventListener('click', function(e) {
                if (e.target === bibtexModal) {
                    bibtexModal.classList.add('hidden');
                }
            });
            
            // Format publication date in a more readable way
            function formatPublicationDate(dateStr) {
                if (!dateStr) return '';
                try {
                    // Check if it's in YYYY-MM-DD format
                    const match = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})/);
                    if (match) {
                        const date = new Date(match[0]);
                        return date.toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'long',
                            day: 'numeric'
                        });
                    }
                    return dateStr;
                } catch (e) {
                    return dateStr;
                }
            }
            
            // Render functions for each paper type
            function renderArXivPaper(paper) {
                // Generate unique ID for checkbox
                const checkboxId = `paper-${paper.source}-${paper.id}`;
                
                // Format authors list
                let authors = 'Unknown authors';
                if (paper.authors && paper.authors.length > 0) {
                    authors = paper.authors.join(', ');
                }
                
                // Format categories into a nice display
                let categoriesHtml = '';
                if (paper.categories && paper.categories.length > 0) {
                    const categories = paper.categories.map(cat => {
                        return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${cat}</span>`;
                    }).join(' ');
                    
                    categoriesHtml = `
                        <div class="text-sm mb-3">
                            <p class="font-medium mb-1">Categories:</p>
                            <div class="flex flex-wrap">${categories}</div>
                        </div>
                    `;
                }
                
                // Create DOI link if available
                let doiLink = '';
                if (paper.doi) {
                    doiLink = `
                        <div class="text-sm mb-1">
                            <span class="font-medium">DOI: </span>
                            <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                        </div>
                    `;
                }
                
                // Format dates
                const publishedDate = paper.published || 'Unknown date';
                const updatedDate = paper.updated || '';
                let updatedInfo = '';
                if (updatedDate && updatedDate !== publishedDate) {
                    updatedInfo = `<p class="text-sm mb-1"><span class="font-medium">Updated:</span> ${updatedDate}</p>`;
                }
                
                // Add summary/abstract if available
                let abstractHtml = '';
                if (paper.summary) {
                    abstractHtml = `
                        <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <p class="font-medium mb-1">Abstract:</p>
                            <p class="text-sm text-gray-700 dark:text-gray-300">${paper.summary}</p>
                        </div>
                    `;
                }
                
                // Add checkbox for selection - checked by default
                const checkboxHtml = `
                    <div class="absolute top-4 left-4">
                        <input type="checkbox" id="${checkboxId}" class="paper-checkbox h-5 w-5 text-primary border-gray-300 rounded focus:ring-primary cursor-pointer" checked>
                    </div>
                `;
                
                // Build the article HTML with arXiv-specific links
                const paperHtml = `
                    ${checkboxHtml}
                    <h3 class="text-lg font-semibold text-primary mb-2 pl-8 pr-20">${paper.title || 'Untitled'}</h3>
                    <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                    <p class="text-sm mb-1"><span class="font-medium">Published:</span> ${publishedDate}</p>
                    ${updatedInfo}
                    <p class="text-sm mb-1"><span class="font-medium">arXiv ID:</span> ${paper.id}</p>
                    ${doiLink}
                    ${categoriesHtml}
                    ${abstractHtml}
                    <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                        <a href="${paper.arxiv_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                            </svg>
                            arXiv Abstract
                        </a>
                        <a href="${paper.pdf_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                            </svg>
                            PDF
                        </a>
                        <button class="analyze-pdf-btn text-primary text-sm flex items-center hover:underline" data-arxiv-id="${paper.id}" data-paper-title="${paper.title.replace(/"/g, '&quot;')}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                            </svg>
                            Analyze with GPT
                        </button>
                    </div>
                `;
                
                // Set up checkbox event handler after the HTML is added to the DOM
                setTimeout(() => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        // Check if this paper is already selected
                        const paperId = paper.source + '-' + paper.id;
                        checkbox.checked = selectedPapers.has(paperId);
                        
                        checkbox.addEventListener('change', () => {
                            togglePaperSelection(paper, checkbox);
                        });
                    }
                }, 0);
                
                return paperHtml;
            }
            
            function renderPubMedPaper(paper) {
                // Generate unique ID for checkbox
                const checkboxId = `paper-${paper.source}-${paper.id}`;
                
                // Format authors list
                let authors = 'Unknown authors';
                if (paper.authors && paper.authors.length > 0) {
                    authors = paper.authors.join(', ');
                }
                
                // Format journal and publication information
                let journalInfo = '';
                if (paper.journal) {
                    journalInfo = `
                        <p class="text-sm mb-1"><span class="font-medium">Journal:</span> ${paper.journal}</p>
                    `;
                }
                
                // Format volume, issue, and pages
                let volumeInfo = '';
                const hasVolume = paper.volume && paper.volume.trim() !== '';
                const hasIssue = paper.issue && paper.issue.trim() !== '';
                const hasPages = paper.pages && paper.pages.trim() !== '';
                
                if (hasVolume || hasIssue || hasPages) {
                    let citationDetails = [];
                    
                    if (hasVolume) {
                        citationDetails.push(`<span class="font-medium">Volume:</span> ${paper.volume}`);
                    }
                    
                    if (hasIssue) {
                        citationDetails.push(`<span class="font-medium">Issue:</span> ${paper.issue}`);
                    }
                    
                    if (hasPages) {
                        citationDetails.push(`<span class="font-medium">Pages:</span> ${paper.pages}`);
                    }
                    
                    volumeInfo = `
                        <p class="text-sm mb-1">${citationDetails.join(' • ')}</p>
                    `;
                }
                
                // Format keywords if available
                let keywordsHtml = '';
                if (paper.keywords && paper.keywords.length > 0) {
                    const keywords = paper.keywords.map(keyword => {
                        return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${keyword}</span>`;
                    }).join(' ');
                    
                    keywordsHtml = `
                        <div class="text-sm mb-3">
                            <p class="font-medium mb-1">Keywords:</p>
                            <div class="flex flex-wrap">${keywords}</div>
                        </div>
                    `;
                }
                
                // Create DOI link if available
                let doiLink = '';
                if (paper.doi) {
                    doiLink = `
                        <div class="text-sm mb-1">
                            <span class="font-medium">DOI: </span>
                            <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                        </div>
                    `;
                }
                
                // Format publication date
                const publishedDate = paper.published || 'Unknown date';
                
                // Add abstract if available
                let abstractHtml = '';
                if (paper.summary) {
                    abstractHtml = `
                        <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <p class="font-medium mb-1">Abstract:</p>
                            <p class="text-sm text-gray-700 dark:text-gray-300">${paper.summary}</p>
                        </div>
                    `;
                }
                
                // Add checkbox for selection - checked by default
                const checkboxHtml = `
                    <div class="absolute top-4 left-4">
                        <input type="checkbox" id="${checkboxId}" class="paper-checkbox h-5 w-5 text-primary border-gray-300 rounded focus:ring-primary cursor-pointer" checked>
                    </div>
                `;
                
                // Generate full-text links
                let fullTextLinksHtml = '';
                if (paper.fullTextLinks && paper.fullTextLinks.length > 0) {
                    fullTextLinksHtml = paper.fullTextLinks.map(link => `
                        <a href="${link.url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                            </svg>
                            ${link.name}
                        </a>
                    `).join('');
                }
                
                // Build the article HTML with PubMed-specific links
                const paperHtml = `
                    ${checkboxHtml}
                    <h3 class="text-lg font-semibold text-primary mb-2 pl-8 pr-20">${paper.title || 'Untitled'}</h3>
                    <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                    ${journalInfo}
                    ${volumeInfo}
                    <p class="text-sm mb-1"><span class="font-medium">Published:</span> ${publishedDate}</p>
                    <p class="text-sm mb-1"><span class="font-medium">PMID:</span> ${paper.id}</p>
                    ${doiLink}
                    ${keywordsHtml}
                    ${abstractHtml}
                    <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                        <a href="${paper.pubmed_url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                            </svg>
                            View on PubMed
                        </a>
                        ${fullTextLinksHtml}
                        ${paper.doi ? `
                        <button class="analyze-pdf-btn text-primary text-sm flex items-center hover:underline" data-doi="${paper.doi}" data-paper-title="${paper.title.replace(/"/g, '&quot;')}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                            </svg>
                            Analyze with GPT
                        </button>
                        ` : ''}
                    </div>
                `;
                
                // Set up checkbox event handler after the HTML is added to the DOM
                setTimeout(() => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        // Check if this paper is already selected
                        const paperId = paper.source + '-' + paper.id;
                        checkbox.checked = selectedPapers.has(paperId);
                        
                        checkbox.addEventListener('change', () => {
                            togglePaperSelection(paper, checkbox);
                        });
                    }
                }, 0);
                
                return paperHtml;
            }
            
            function renderSemanticScholarPaper(paper) {
                // Generate unique ID for checkbox
                const checkboxId = `paper-${paper.source}-${paper.paperId}`;
                
                // Format authors list
                let authors = 'Unknown authors';
                if (paper.authors && paper.authors.length > 0) {
                    authors = paper.authors.join(', ');
                }
                
                // Format fields/topics into a nice display
                let fieldsHtml = '';
                if (paper.fields && paper.fields.length > 0) {
                    const fields = paper.fields.map(field => {
                        return `<span class="inline-block bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-2 py-1 text-xs mr-1 mb-1">${field}</span>`;
                    }).join(' ');
                    
                    fieldsHtml = `
                        <div class="text-sm mb-3">
                            <p class="font-medium mb-1">Fields of Study:</p>
                            <div class="flex flex-wrap">${fields}</div>
                        </div>
                    `;
                }
                
                // Format venue/publication info
                let venueInfo = '';
                let venueText = '';
                
                if (paper.venue) {
                    // Check if venue is an object and handle it properly
                    if (typeof paper.venue === 'object') {
                        venueText = paper.venue.name || paper.venue.text || JSON.stringify(paper.venue).replace(/[{}"]/g, '');
                    } else {
                        venueText = paper.venue;
                    }
                    
                    venueInfo = `
                        <p class="text-sm mb-1"><span class="font-medium">Venue:</span> ${venueText}</p>
                    `;
                }
                
                // Create DOI link if available
                let doiLink = '';
                if (paper.doi) {
                    doiLink = `
                        <div class="text-sm mb-1">
                            <span class="font-medium">DOI: </span>
                            <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary hover:underline">${paper.doi}</a>
                        </div>
                    `;
                }
                
                // Format publication date if available, otherwise use year
                let dateInfo = '';
                if (paper.publicationDate) {
                    const formattedDate = formatPublicationDate(paper.publicationDate);
                    dateInfo = `<p class="text-sm mb-1"><span class="font-medium">Published:</span> ${formattedDate}</p>`;
                } else {
                    dateInfo = `<p class="text-sm mb-1"><span class="font-medium">Year:</span> ${paper.year || 'Unknown year'}</p>`;
                }
                
                // Format citation count
                let citationInfo = '';
                if (paper.citationCount !== undefined) {
                    citationInfo = `
                        <p class="text-sm mb-1"><span class="font-medium">Citations:</span> ${paper.citationCount}</p>
                    `;
                }
                
                // Add abstract if available
                let abstractHtml = '';
                if (paper.abstract) {
                    abstractHtml = `
                        <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                            <p class="font-medium mb-1">Abstract:</p>
                            <p class="text-sm text-gray-700 dark:text-gray-300">${paper.abstract}</p>
                        </div>
                    `;
                }
                
                // Add checkbox for selection - checked by default
                const checkboxHtml = `
                    <div class="absolute top-4 left-4">
                        <input type="checkbox" id="${checkboxId}" class="paper-checkbox h-5 w-5 text-primary border-gray-300 rounded focus:ring-primary cursor-pointer" checked>
                    </div>
                `;
                
                // Build the article HTML with Semantic Scholar-specific links
                const paperHtml = `
                    ${checkboxHtml}
                    <h3 class="text-lg font-semibold text-primary mb-2 pl-8 pr-20">${paper.title || 'Untitled'}</h3>
                    <p class="text-sm mb-1"><span class="font-medium">Authors:</span> ${authors}</p>
                    ${venueInfo}
                    ${dateInfo}
                    ${citationInfo}
                    <p class="text-sm mb-1"><span class="font-medium">Semantic Scholar ID:</span> ${paper.paperId || 'Unknown'}</p>
                    ${doiLink}
                    ${fieldsHtml}
                    ${abstractHtml}
                    <div class="flex flex-wrap gap-2 mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                        <a href="${paper.url}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 010-5.656l4-4a4 4 0 015.656 5.656l-1.101 1.102" />
                            </svg>
                            View on Semantic Scholar
                        </a>
                        ${paper.doi ? `
                        <a href="https://doi.org/${paper.doi}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                            </svg>
                            View via DOI
                        </a>
                        ` : ''}
                        ${paper.pdfUrl ? `
                        <a href="${paper.pdfUrl}" target="_blank" class="text-primary text-sm flex items-center hover:underline">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                            </svg>
                            PDF
                        </a>
                        ` : ''}
                        ${(paper.doi || paper.pdfUrl) ? `
                        <button class="analyze-pdf-btn text-primary text-sm flex items-center hover:underline" 
                                data-${paper.doi ? 'doi' : 'url'}="${paper.doi || paper.pdfUrl}" 
                                data-paper-title="${paper.title.replace(/"/g, '&quot;')}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                            </svg>
                            Analyze with GPT
                        </button>
                        ` : ''}
                    </div>
                `;
                
                // Set up checkbox event handler after the HTML is added to the DOM
                setTimeout(() => {
                    const checkbox = document.getElementById(checkboxId);
                    if (checkbox) {
                        // Check if this paper is already selected
                        const paperId = paper.source + '-' + paper.paperId;
                        checkbox.checked = selectedPapers.has(paperId);
                        
                        checkbox.addEventListener('change', () => {
                            togglePaperSelection(paper, checkbox);
                        });
                    }
                }, 0);
                
                return paperHtml;
            }
            
            // Main search function that calls appropriate search method based on selected databases
            async function searchAndDisplay(queryInput, maxResults, dateRange) {
                // Reset previous search state
                resetSearchState();
                showLoading();
                
                // Get selected databases
                const selectedDatabases = [];
                if (arxivCheckbox.checked) selectedDatabases.push('arXiv');
                if (pubmedCheckbox.checked) selectedDatabases.push('PubMed');
                if (semanticCheckbox.checked) selectedDatabases.push('Semantic Scholar');
                
                // Split the query by semicolons and trim each keyword
                const queries = queryInput.split(';').map(q => q.trim()).filter(q => q);
                
                // Use original query if no semicolons were found
                const searchQueries = queries.length > 0 ? queries : [queryInput.trim()];
                
                // Update loading message
                const loadingText = loadingElement.querySelector('p');
                if (selectedDatabases.length === 1) {
                    loadingText.textContent = `Searching ${selectedDatabases[0]} database for ${searchQueries.length} keyword(s)...`;
                } else {
                    loadingText.textContent = `Searching ${selectedDatabases.length} databases for ${searchQueries.length} keyword(s)...`;
                }
                
                try {
                    if (selectedDatabases.length === 0) {
                        throw new Error('Please select at least one database to search');
                    }
                    
                    // Array to hold all search results
                    const allResults = [];
                    
                    // For each query, search all selected databases
                    for (const query of searchQueries) {
                        // Start parallel searches for all selected databases
                        const searchPromises = selectedDatabases.map(db => 
                            searchDatabase(db, query, maxResults, dateRange)
                        );
                        
                        // Wait for all searches to complete
                        const results = await Promise.all(searchPromises);
                        
                        // Add the matching keyword to each result
                        results.forEach(result => {
                            if (result.success && result.data && result.data.papers) {
                                result.data.papers.forEach(paper => {
                                    paper.matchedQuery = query;
                                });
                            }
                        });
                        
                        // Add results to the combined array
                        allResults.push(...results);
                    }
                    
                    // Display combined results
                    displayCombinedResults(allResults);
                    
                } catch (error) {
                    console.error('Search error:', error);
                    showError(`Error retrieving search results: ${error.message}. Please try again later or refine your search query.`);
                } finally {
                    hideLoading();
                }
            }
            
            // Set up checkbox event handlers and select/clear all functionality
            function updateSelectedDatabases() {
                // Get all selected databases
                const selectedDatabases = [];
                if (arxivCheckbox.checked) selectedDatabases.push('arXiv');
                if (pubmedCheckbox.checked) selectedDatabases.push('PubMed');
                if (semanticCheckbox.checked) selectedDatabases.push('Semantic Scholar');

                // Update message and search button
                if (selectedDatabases.length === 0) {
                    databaseMessage.textContent = 'Please select at least one database';
                    searchButton.disabled = true;
                    searchButtonText.textContent = 'Search';
                } else if (selectedDatabases.length === 1) {
                    databaseMessage.textContent = `Searching in ${selectedDatabases[0]} database only`;
                    searchButton.disabled = false;
                    searchButtonText.textContent = `Search ${selectedDatabases[0]}`;
                } else {
                    databaseMessage.textContent = `Searching in ${selectedDatabases.length} databases: ${selectedDatabases.join(', ')}`;
                    searchButton.disabled = false;
                    searchButtonText.textContent = 'Search Multiple Databases';
                }
                
                // Update title based on selected databases
                updatePageTitle(selectedDatabases);
            }
            
            function updatePageTitle(selectedDatabases) {
                const headerTitle = document.querySelector('header h1');
                const headerDescription = document.querySelector('header p');
                
                if (selectedDatabases.length === 0) {
                    headerTitle.textContent = 'JavaScript Academic Search';
                    headerDescription.textContent = 'Select at least one database to search academic papers';
                } else if (selectedDatabases.length === 1) {
                    if (selectedDatabases[0] === 'arXiv') {
                        headerTitle.textContent = 'JavaScript arXiv Search';
                        headerDescription.textContent = 'Search academic papers in physics, mathematics, computer science, and more';
                    } else if (selectedDatabases[0] === 'PubMed') {
                        headerTitle.textContent = 'JavaScript PubMed Search';
                        headerDescription.textContent = 'Search medical and biomedical research papers from the National Library of Medicine';
                    } else if (selectedDatabases[0] === 'Semantic Scholar') {
                        headerTitle.textContent = 'JavaScript Semantic Scholar Search';
                        headerDescription.textContent = 'Search academic papers using AI-powered research tool by Allen Institute for AI';
                    }
                } else {
                    headerTitle.textContent = 'Multi-Source Academic Search';
                    headerDescription.textContent = 'Search across multiple academic databases simultaneously';
                }
            }
            
            // Set up event listeners for checkboxes
            arxivCheckbox.addEventListener('change', updateSelectedDatabases);
            pubmedCheckbox.addEventListener('change', updateSelectedDatabases);
            semanticCheckbox.addEventListener('change', updateSelectedDatabases);
            
            // Select all button
            selectAllButton.addEventListener('click', function() {
                arxivCheckbox.checked = true;
                pubmedCheckbox.checked = true;
                semanticCheckbox.checked = true;
                updateSelectedDatabases();
            });
            
            // Clear all button
            clearAllButton.addEventListener('click', function() {
                arxivCheckbox.checked = false;
                pubmedCheckbox.checked = false;
                semanticCheckbox.checked = false;
                updateSelectedDatabases();
            });
            
            // Initialize with default message
            updateSelectedDatabases();
            
            // Keyword extraction functionality
            const extractKeywordsBtn = document.getElementById('extract-keywords-btn');
            const extractKeywordsModal = document.getElementById('extract-keywords-modal');
            const closeExtractModalBtn = document.getElementById('close-extract-modal');
            const extractTextInput = document.getElementById('extract-text-input');
            const extractionResults = document.getElementById('extraction-results');
            const extractionLoading = document.getElementById('extraction-loading');
            const extractionError = document.getElementById('extraction-error');
            const extractionErrorMessage = document.getElementById('extraction-error-message');
            const keywordsContainer = document.getElementById('keywords-container');
            const extractKeywordsBtnSubmit = document.getElementById('extract-keywords-btn-submit');
            const useAllKeywordsBtn = document.getElementById('use-all-keywords');
            const useSelectedKeywordsBtn = document.getElementById('use-selected-keywords');
            
            // Show the keyword extraction modal
            extractKeywordsBtn.addEventListener('click', function() {
                extractKeywordsModal.classList.remove('hidden');
                extractTextInput.focus();
                // Reset the modal state
                extractionResults.classList.add('hidden');
                extractionLoading.classList.add('hidden');
                extractionError.classList.add('hidden');
                keywordsContainer.innerHTML = '';
                extractTextInput.value = '';
            });
            
            // Close the modal
            closeExtractModalBtn.addEventListener('click', function() {
                extractKeywordsModal.classList.add('hidden');
            });
            
            // Close modal when clicking outside
            extractKeywordsModal.addEventListener('click', function(e) {
                if (e.target === extractKeywordsModal) {
                    extractKeywordsModal.classList.add('hidden');
                }
            });
            
            // Handle keyword extraction submission
            extractKeywordsBtnSubmit.addEventListener('click', async function() {
                const text = extractTextInput.value.trim();
                if (!text) {
                    showExtractionError('Please enter some text to extract keywords from.');
                    return;
                }
                
                // Show loading state
                extractionResults.classList.add('hidden');
                extractionLoading.classList.remove('hidden');
                extractionError.classList.add('hidden');
                
                try {
                    // Send the text to Claude for keyword extraction
                    const prompt = `@Claude-3.7-Sonnet Please analyze the following academic text and extract the most important keywords or phrases in ENGLISH that would be useful for searching academic databases. Focus on technical terms, methodologies, research topics, and key concepts.
                    
                    Even if the input text is in Chinese or another non-English language, please extract or translate the key concepts into English keywords, as these will be used for searching in academic databases that primarily use English.
                    
                    Return ONLY a JSON array of English strings, without any explanation or formatting. Each keyword should be a separate string in the array. For example:
                    ["machine learning", "neural networks", "computer vision"]
                    
                    Do not include general or very common terms. Focus on specific, technical terms relevant to the field. Aim for 5-10 keywords maximum, preferring quality and specificity over quantity. Here is the text:
                    
                    "${text}"`;
                    
                    // Register a handler for the response
                    window.Poe.registerHandler("keyword-extractor", (result, context) => {
                        if (result.status === "error") {
                            showExtractionError("Error from Claude: " + (result.statusText || "Unknown error"));
                            extractionLoading.classList.add('hidden');
                            return;
                        }
                        
                        if (result.responses && result.responses.length > 0) {
                            const response = result.responses[0];
                            
                            if (response.status === "complete") {
                                try {
                                    // Try to parse JSON array from Claude's response
                                    let responseText = response.content.trim();
                                    
                                    // Strip any markdown code block formatting if present
                                    if (responseText.startsWith("```") && responseText.endsWith("```")) {
                                        responseText = responseText.substring(3, responseText.length - 3).trim();
                                        
                                        // Remove language indicator if present (e.g., ```json)
                                        if (responseText.startsWith("json")) {
                                            responseText = responseText.substring(4).trim();
                                        }
                                    }
                                    
                                    // Parse the JSON array
                                    const keywords = JSON.parse(responseText);
                                    
                                    if (Array.isArray(keywords) && keywords.length > 0) {
                                        displayExtractedKeywords(keywords);
                                    } else {
                                        showExtractionError("No relevant keywords found in the text.");
                                    }
                                } catch (parseError) {
                                    console.error("Error parsing Claude's response:", parseError);
                                    showExtractionError("Could not parse the keywords from Claude's response. Please try again.");
                                }
                                
                                extractionLoading.classList.add('hidden');
                            }
                        }
                    });
                    
                    // Send the prompt to Claude
                    await window.Poe.sendUserMessage(prompt, {
                        handler: "keyword-extractor",
                        stream: false,
                        openChat: false
                    });
                    
                } catch (error) {
                    console.error('Error extracting keywords:', error);
                    showExtractionError('Error connecting to Claude: ' + error.message);
                    extractionLoading.classList.add('hidden');
                }
            });
            
            // Display extracted keywords
            function displayExtractedKeywords(keywords) {
                keywordsContainer.innerHTML = '';
                
                keywords.forEach(keyword => {
                    const keywordElement = document.createElement('div');
                    keywordElement.className = 'flex items-center';
                    keywordElement.innerHTML = `
                        <input type="checkbox" class="keyword-checkbox h-4 w-4 text-primary border-gray-300 rounded focus:ring-primary mr-2" checked data-keyword="${keyword}">
                        <span class="bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-full px-3 py-1.5 text-sm">${keyword}</span>
                    `;
                    keywordsContainer.appendChild(keywordElement);
                });
                
                extractionResults.classList.remove('hidden');
            }
            
            // Show extraction error
            function showExtractionError(message) {
                extractionErrorMessage.textContent = message;
                extractionError.classList.remove('hidden');
            }
            
            // Use all extracted keywords
            useAllKeywordsBtn.addEventListener('click', function() {
                const keywords = Array.from(document.querySelectorAll('.keyword-checkbox'))
                    .map(checkbox => checkbox.dataset.keyword);
                
                if (keywords.length > 0) {
                    queryInput.value = keywords.join('; ');
                    extractKeywordsModal.classList.add('hidden');
                }
            });
            
            // Use only selected keywords
            useSelectedKeywordsBtn.addEventListener('click', function() {
                const selectedKeywords = Array.from(document.querySelectorAll('.keyword-checkbox:checked'))
                    .map(checkbox => checkbox.dataset.keyword);
                
                if (selectedKeywords.length > 0) {
                    queryInput.value = selectedKeywords.join('; ');
                    extractKeywordsModal.classList.add('hidden');
                } else {
                    showExtractionError('Please select at least one keyword.');
                }
            });
            
            // Handle form submission
            searchForm.addEventListener('submit', function(e) {
                e.preventDefault();
                
                const query = queryInput.value.trim();
                if (!query) return;
                
                const maxResults = parseInt(resultsCountSelect.value, 10);
                const dateRange = dateRangeSelect.value;
                
                // Count keywords for message display
                const keywordCount = query.split(';').filter(q => q.trim()).length || 1;
                const keywordText = keywordCount > 1 ? 
                    `Searching for ${keywordCount} keywords: "${query.split(';').map(q => q.trim()).join('", "')}"` : 
                    `Searching for: "${query}"`;
                    
                // Show keyword message in error container (repurposing it as an info container)
                errorMessage.textContent = keywordText;
                errorContainer.classList.remove('hidden');
                errorContainer.classList.remove('bg-red-100', 'dark:bg-red-900', 'border-red-200', 'dark:border-red-800', 'text-red-700', 'dark:text-red-200');
                errorContainer.classList.add('bg-blue-100', 'dark:bg-blue-900', 'border-blue-200', 'dark:border-blue-800', 'text-blue-700', 'dark:text-blue-200');
                
                // Call the search function with the query
                searchAndDisplay(query, maxResults, dateRange);
            });
            
            // Add pagination event listeners
            prevPageBtn.addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    displayResultsPage(currentPage);
                    updatePaginationUI();
                }
            });
            
            nextPageBtn.addEventListener('click', function() {
                if (currentPage < totalPagesCount) {
                    currentPage++;
                    displayResultsPage(currentPage);
                    updatePaginationUI();
                }
            });
            
            // Listen for changes to the results count select to update pagination
            resultsCountSelect.addEventListener('change', function() {
                if (allSearchResults.length > 0) {
                    resultsPerPage = parseInt(this.value, 10);
                    currentPage = 1;
                    totalPagesCount = Math.ceil(allSearchResults.length / resultsPerPage);
                    updatePaginationUI();
                    displayResultsPage(currentPage);
                }
            });
            
            // Helper functions
            function resetSearchState() {
                hideResults();
                hideNoResults();
                hideError();
                // viewMoreContainer reference removed
            }
            
            function showLoading() {
                loadingElement.classList.remove('hidden');
                searchButton.disabled = true;
                searchButton.classList.add('opacity-70');
            }
            
            function hideLoading() {
                loadingElement.classList.add('hidden');
                searchButton.disabled = false;
                searchButton.classList.remove('opacity-70');
            }
            
            function showResults() {
                resultsContainer.classList.remove('hidden');
                noResults.classList.add('hidden');
            }
            
            function hideResults() {
                resultsContainer.classList.add('hidden');
            }
            
            function showNoResults() {
                noResults.classList.remove('hidden');
                resultsContainer.classList.add('hidden');
            }
            
            function hideNoResults() {
                noResults.classList.add('hidden');
            }
            
            function showError(message) {
                errorMessage.textContent = message;
                errorContainer.classList.remove('hidden');
            }
            
            function hideError() {
                errorContainer.classList.add('hidden');
            }
        });
        
        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }
        function escapeHTML(str) {
            if (!str) return '';
            // Make sure str is actually a string
            str = String(str);
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }
                        

    </script>
</body>
</html>











